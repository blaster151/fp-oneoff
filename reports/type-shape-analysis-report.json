{
  "summary": {
    "totalTypes": 393,
    "potentialDuplicates": 19,
    "highConfidenceDuplicates": 1
  },
  "duplicates": [
    {
      "shapeKey": "primitive:{\n  monoidLaws: LawCheck<{ a: A",
      "types": [
        {
          "name": "EMMonoidLawResults",
          "type": "type",
          "file": "src/types/strong-monad.ts",
          "line": 389,
          "definition": "{\n  monoidLaws: LawCheck<{ a: A",
          "shape": {
            "type": "primitive",
            "definition": "{\n  monoidLaws: LawCheck<{ a: A"
          }
        },
        {
          "name": "EMMonoidWitness",
          "type": "type",
          "file": "src/types/witnesses.ts",
          "line": 78,
          "definition": "{\n  monoidLaws: LawCheck<{ a: A",
          "shape": {
            "type": "primitive",
            "definition": "{\n  monoidLaws: LawCheck<{ a: A"
          }
        }
      ],
      "confidence": 0.7555555555555555
    },
    {
      "shapeKey": "primitive:string",
      "types": [
        {
          "name": "Obj",
          "type": "type",
          "file": "src/types/sset-quasicat.ts",
          "line": 9,
          "definition": "string",
          "shape": {
            "type": "primitive",
            "definition": "string"
          }
        },
        {
          "name": "HomologyObj",
          "type": "type",
          "file": "src/types/catkit-homology.ts",
          "line": 13,
          "definition": "string",
          "shape": {
            "type": "primitive",
            "definition": "string"
          }
        },
        {
          "name": "Vertex",
          "type": "type",
          "file": "src/types/quiver-pushout.ts",
          "line": 13,
          "definition": "string",
          "shape": {
            "type": "primitive",
            "definition": "string"
          }
        },
        {
          "name": "EdgeLabel",
          "type": "type",
          "file": "src/types/quiver-pushout.ts",
          "line": 14,
          "definition": "string",
          "shape": {
            "type": "primitive",
            "definition": "string"
          }
        }
      ],
      "confidence": 0.5863636363636364
    },
    {
      "shapeKey": "primitive:'naive' | 'bit'",
      "types": [
        {
          "name": "RelImpl",
          "type": "type",
          "file": "src/types/config.ts",
          "line": 5,
          "definition": "'naive' | 'bit'",
          "shape": {
            "type": "primitive",
            "definition": "'naive' | 'bit'"
          }
        },
        {
          "name": "RelStrategy",
          "type": "type",
          "file": "src/types/rel-common.ts",
          "line": 99,
          "definition": "'naive' | 'bit'",
          "shape": {
            "type": "primitive",
            "definition": "'naive' | 'bit'"
          }
        }
      ],
      "confidence": 0.5863636363636364
    },
    {
      "shapeKey": "primitive:| { ok: true",
      "types": [
        {
          "name": "HoareWitness",
          "type": "type",
          "file": "src/types/allegory-witness.ts",
          "line": 72,
          "definition": "| { ok: true",
          "shape": {
            "type": "primitive",
            "definition": "| { ok: true"
          }
        },
        {
          "name": "Validation",
          "type": "type",
          "file": "src/types/freeapp-coyo.ts",
          "line": 84,
          "definition": "| { ok: true",
          "shape": {
            "type": "primitive",
            "definition": "| { ok: true"
          }
        },
        {
          "name": "LawCheck",
          "type": "type",
          "file": "src/types/witnesses.ts",
          "line": 25,
          "definition": "| { ok: true",
          "shape": {
            "type": "primitive",
            "definition": "| { ok: true"
          }
        }
      ],
      "confidence": 0.575
    },
    {
      "shapeKey": "interface:6:add:(x: A, y: A) => A|add:method|mul:(x: A, y: A) => A|mul:method|one:A|zero:A",
      "types": [
        {
          "name": "Ring",
          "type": "interface",
          "file": "src/laws/examples/ESLintDemo.ts",
          "line": 31,
          "properties": [
            {
              "name": "add",
              "optional": false,
              "type": "(x: A, y: A) => A"
            },
            {
              "name": "add",
              "optional": false,
              "type": "method",
              "signature": "(x: A, y: A)",
              "returnType": "A"
            },
            {
              "name": "mul",
              "optional": false,
              "type": "(x: A, y: A) => A"
            },
            {
              "name": "mul",
              "optional": false,
              "type": "method",
              "signature": "(x: A, y: A)",
              "returnType": "A"
            },
            {
              "name": "zero",
              "optional": false,
              "type": "A"
            },
            {
              "name": "one",
              "optional": false,
              "type": "A"
            }
          ],
          "shape": {
            "propertyCount": 6,
            "properties": [
              {
                "name": "add",
                "optional": false,
                "type": "(x: A, y: A) => A"
              },
              {
                "name": "add",
                "optional": false,
                "type": "method"
              },
              {
                "name": "mul",
                "optional": false,
                "type": "(x: A, y: A) => A"
              },
              {
                "name": "mul",
                "optional": false,
                "type": "method"
              },
              {
                "name": "one",
                "optional": false,
                "type": "A"
              },
              {
                "name": "zero",
                "optional": false,
                "type": "A"
              }
            ]
          }
        },
        {
          "name": "Semiring",
          "type": "interface",
          "file": "src/types/algebraic.ts",
          "line": 32,
          "properties": [
            {
              "name": "add",
              "optional": false,
              "type": "(x: A, y: A) => A"
            },
            {
              "name": "add",
              "optional": false,
              "type": "method",
              "signature": "(x: A, y: A)",
              "returnType": "A"
            },
            {
              "name": "zero",
              "optional": false,
              "type": "A"
            },
            {
              "name": "mul",
              "optional": false,
              "type": "(x: A, y: A) => A"
            },
            {
              "name": "mul",
              "optional": false,
              "type": "method",
              "signature": "(x: A, y: A)",
              "returnType": "A"
            },
            {
              "name": "one",
              "optional": false,
              "type": "A"
            }
          ],
          "shape": {
            "propertyCount": 6,
            "properties": [
              {
                "name": "add",
                "optional": false,
                "type": "(x: A, y: A) => A"
              },
              {
                "name": "add",
                "optional": false,
                "type": "method"
              },
              {
                "name": "mul",
                "optional": false,
                "type": "(x: A, y: A) => A"
              },
              {
                "name": "mul",
                "optional": false,
                "type": "method"
              },
              {
                "name": "one",
                "optional": false,
                "type": "A"
              },
              {
                "name": "zero",
                "optional": false,
                "type": "A"
              }
            ]
          }
        }
      ],
      "confidence": 0.5
    },
    {
      "shapeKey": "primitive:{\n  commutes: boolean",
      "types": [
        {
          "name": "SquareWitness",
          "type": "type",
          "file": "src/types/witnesses.ts",
          "line": 43,
          "definition": "{\n  commutes: boolean",
          "shape": {
            "type": "primitive",
            "definition": "{\n  commutes: boolean"
          }
        },
        {
          "name": "TriangleResult",
          "type": "type",
          "file": "src/universal/monad/Diagram.ts",
          "line": 8,
          "definition": "{\n  commutes: boolean",
          "shape": {
            "type": "primitive",
            "definition": "{\n  commutes: boolean"
          }
        },
        {
          "name": "SquareResult",
          "type": "type",
          "file": "src/universal/monad/Diagram.ts",
          "line": 13,
          "definition": "{\n  commutes: boolean",
          "shape": {
            "type": "primitive",
            "definition": "{\n  commutes: boolean"
          }
        }
      ],
      "confidence": 0.4807692307692308
    },
    {
      "shapeKey": "primitive:{\n  sig: Signature",
      "types": [
        {
          "name": "UAAlgebra",
          "type": "type",
          "file": "src/universal/Algebra.ts",
          "line": 5,
          "definition": "{\n  sig: Signature",
          "shape": {
            "type": "primitive",
            "definition": "{\n  sig: Signature"
          }
        },
        {
          "name": "Lawvere",
          "type": "type",
          "file": "src/universal/lawvere/Lawvere.ts",
          "line": 11,
          "definition": "{\n  sig: Signature",
          "shape": {
            "type": "primitive",
            "definition": "{\n  sig: Signature"
          }
        }
      ],
      "confidence": 0.41666666666666663
    },
    {
      "shapeKey": "primitive:{\n  elems: A[]",
      "types": [
        {
          "name": "FiniteRing",
          "type": "type",
          "file": "src/structures/ring/Ring.ts",
          "line": 5,
          "definition": "{\n  elems: A[]",
          "shape": {
            "type": "primitive",
            "definition": "{\n  elems: A[]"
          }
        },
        {
          "name": "FiniteSemigroup",
          "type": "type",
          "file": "src/algebra/semiringlike/Semigroup.ts",
          "line": 1,
          "definition": "{\n  elems: A[]",
          "shape": {
            "type": "primitive",
            "definition": "{\n  elems: A[]"
          }
        },
        {
          "name": "FiniteSet",
          "type": "type",
          "file": "src/set/Set.ts",
          "line": 6,
          "definition": "{\n  elems: A[]",
          "shape": {
            "type": "primitive",
            "definition": "{\n  elems: A[]"
          }
        }
      ],
      "confidence": 0.35
    },
    {
      "shapeKey": "primitive:{\n  carrier: X[]",
      "types": [
        {
          "name": "Moore",
          "type": "type",
          "file": "src/coalgebra/Coalgebra.ts",
          "line": 2,
          "definition": "{\n  carrier: X[]",
          "shape": {
            "type": "primitive",
            "definition": "{\n  carrier: X[]"
          }
        },
        {
          "name": "Top",
          "type": "type",
          "file": "src/top/Topology.ts",
          "line": 2,
          "definition": "{\n  carrier: X[]",
          "shape": {
            "type": "primitive",
            "definition": "{\n  carrier: X[]"
          }
        }
      ],
      "confidence": 0.35
    },
    {
      "shapeKey": "interface:0:",
      "types": [
        {
          "name": "Congruence",
          "type": "interface",
          "file": "src/algebra/group/Congruence.ts",
          "line": 5,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "EnhancedCongruence",
          "type": "interface",
          "file": "src/algebra/group/EnhancedCongruence.ts",
          "line": 7,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "EnhancedQuotient",
          "type": "interface",
          "file": "src/algebra/group/EnhancedQuotientGroup.ts",
          "line": 16,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "Subgroup",
          "type": "interface",
          "file": "src/algebra/group/NormalSubgroup.ts",
          "line": 7,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "HFunctor",
          "type": "interface",
          "file": "src/gadt/HFun.ts",
          "line": 5,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "Category",
          "type": "interface",
          "file": "src/types/catkit-comma-categories.ts",
          "line": 17,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "GaloisConnection",
          "type": "interface",
          "file": "src/types/catkit-posets.ts",
          "line": 134,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "Pure",
          "type": "interface",
          "file": "src/types/advanced.ts",
          "line": 316,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "Suspend",
          "type": "interface",
          "file": "src/types/advanced.ts",
          "line": 321,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "Quiver",
          "type": "interface",
          "file": "src/types/category-to-nerve-sset.ts",
          "line": 22,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "QuiverMorphism",
          "type": "interface",
          "file": "src/types/quiver-pushout.ts",
          "line": 16,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "DoubleCategory",
          "type": "interface",
          "file": "src/types/double-lax-functor.ts",
          "line": 25,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "ProTrans",
          "type": "interface",
          "file": "src/types/category-to-nerve-sset.ts",
          "line": 1101,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "KanExtensionProblem",
          "type": "interface",
          "file": "src/types/catkit-comma-kan-bridge.ts",
          "line": 21,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "DoubleLaxFunctor",
          "type": "interface",
          "file": "src/types/double-lax-functor.ts",
          "line": 14,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "DoubleNaturalTransformation",
          "type": "interface",
          "file": "src/types/double-lax-functor.ts",
          "line": 84,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "ApplicativeOps",
          "type": "interface",
          "file": "src/types/freeapp-coyo.ts",
          "line": 65,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "URItoKindFree",
          "type": "interface",
          "file": "src/types/optics-free.ts",
          "line": 5,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "URItoKind2Free",
          "type": "interface",
          "file": "src/types/optics-free.ts",
          "line": 8,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "URItoKind3Free",
          "type": "interface",
          "file": "src/types/optics-free.ts",
          "line": 11,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "AuditEntry",
          "type": "interface",
          "file": "src/types/quiver-pushout.ts",
          "line": 22,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "PushoutResult",
          "type": "interface",
          "file": "src/types/quiver-pushout.ts",
          "line": 34,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "CoequalizerResult",
          "type": "interface",
          "file": "src/types/quiver-pushout.ts",
          "line": 41,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "MigrationStep",
          "type": "interface",
          "file": "src/types/quiver-pushout.ts",
          "line": 382,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "IRel",
          "type": "interface",
          "file": "src/types/rel-common.ts",
          "line": 9,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "RelFactory",
          "type": "interface",
          "file": "src/types/rel-common.ts",
          "line": 101,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "StrongMonad",
          "type": "interface",
          "file": "src/types/strong-monad.ts",
          "line": 20,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        },
        {
          "name": "EMAlgebra",
          "type": "interface",
          "file": "src/types/strong-monad.ts",
          "line": 141,
          "properties": [],
          "shape": {
            "propertyCount": 0,
            "properties": []
          }
        }
      ],
      "confidence": 0.3277777777777778
    },
    {
      "shapeKey": "primitive:{ name: string",
      "types": [
        {
          "name": "Rule",
          "type": "type",
          "file": "src/types/optics-rewrite.ts",
          "line": 157,
          "definition": "{ name: string",
          "shape": {
            "type": "primitive",
            "definition": "{ name: string"
          }
        },
        {
          "name": "OpSym",
          "type": "type",
          "file": "src/universal/Signature.ts",
          "line": 1,
          "definition": "{ name: string",
          "shape": {
            "type": "primitive",
            "definition": "{ name: string"
          }
        }
      ],
      "confidence": 0.25
    },
    {
      "shapeKey": "primitive:number[][]",
      "types": [
        {
          "name": "CayleyTable",
          "type": "type",
          "file": "src/algebra/group/iso/CanonicalTable.ts",
          "line": 5,
          "definition": "number[][]",
          "shape": {
            "type": "primitive",
            "definition": "number[][]"
          }
        },
        {
          "name": "Stoch",
          "type": "type",
          "file": "src/prob/Markov.ts",
          "line": 4,
          "definition": "number[][]",
          "shape": {
            "type": "primitive",
            "definition": "number[][]"
          }
        },
        {
          "name": "Matrix",
          "type": "type",
          "file": "src/types/snf-surface-api.ts",
          "line": 10,
          "definition": "number[][]",
          "shape": {
            "type": "primitive",
            "definition": "number[][]"
          }
        }
      ],
      "confidence": 0.14090909090909093
    },
    {
      "shapeKey": "primitive:{\n  key:string",
      "types": [
        {
          "name": "Edge",
          "type": "type",
          "file": "src/types/sset-quasicat.ts",
          "line": 11,
          "definition": "{\n  key:string",
          "shape": {
            "type": "primitive",
            "definition": "{\n  key:string"
          }
        },
        {
          "name": "Tri",
          "type": "type",
          "file": "src/types/sset-quasicat.ts",
          "line": 16,
          "definition": "{\n  key:string",
          "shape": {
            "type": "primitive",
            "definition": "{\n  key:string"
          }
        },
        {
          "name": "Tet",
          "type": "type",
          "file": "src/types/sset-quasicat.ts",
          "line": 22,
          "definition": "{\n  key:string",
          "shape": {
            "type": "primitive",
            "definition": "{\n  key:string"
          }
        }
      ],
      "confidence": 0.1
    },
    {
      "shapeKey": "primitive:{\n  src: SetObj<any>",
      "types": [
        {
          "name": "Rel",
          "type": "type",
          "file": "src/types/category-to-nerve-sset.ts",
          "line": 761,
          "definition": "{\n  src: SetObj<any>",
          "shape": {
            "type": "primitive",
            "definition": "{\n  src: SetObj<any>"
          }
        },
        {
          "name": "FnM",
          "type": "type",
          "file": "src/types/category-to-nerve-sset.ts",
          "line": 768,
          "definition": "{\n  src: SetObj<any>",
          "shape": {
            "type": "primitive",
            "definition": "{\n  src: SetObj<any>"
          }
        }
      ],
      "confidence": 0.1
    },
    {
      "shapeKey": "primitive:{ src: HomologyObj",
      "types": [
        {
          "name": "HomologyEdge",
          "type": "type",
          "file": "src/types/catkit-homology.ts",
          "line": 14,
          "definition": "{ src: HomologyObj",
          "shape": {
            "type": "primitive",
            "definition": "{ src: HomologyObj"
          }
        },
        {
          "name": "HomologyPath",
          "type": "type",
          "file": "src/types/catkit-homology.ts",
          "line": 15,
          "definition": "{ src: HomologyObj",
          "shape": {
            "type": "primitive",
            "definition": "{ src: HomologyObj"
          }
        }
      ],
      "confidence": 0.1
    },
    {
      "shapeKey": "function:Brand<{\n  readonly get: (s: S) => A",
      "types": [
        {
          "name": "SafeGetter",
          "type": "type",
          "file": "src/types/optics-profunctor-bridge-safe.ts",
          "line": 15,
          "definition": "Brand<{\n  readonly get: (s: S) => A",
          "shape": {
            "type": "function",
            "signature": "Brand<{\n  readonly get: (s: S) => A"
          }
        },
        {
          "name": "SafeLens",
          "type": "type",
          "file": "src/types/optics-profunctor-bridge-safe.ts",
          "line": 19,
          "definition": "Brand<{\n  readonly get: (s: S) => A",
          "shape": {
            "type": "function",
            "signature": "Brand<{\n  readonly get: (s: S) => A"
          }
        }
      ],
      "confidence": 0.1
    },
    {
      "shapeKey": "primitive:| { equal: true",
      "types": [
        {
          "name": "RelEqWitness",
          "type": "type",
          "file": "src/types/witnesses.ts",
          "line": 15,
          "definition": "| { equal: true",
          "shape": {
            "type": "primitive",
            "definition": "| { equal: true"
          }
        },
        {
          "name": "FunEqWitness",
          "type": "type",
          "file": "src/types/witnesses.ts",
          "line": 20,
          "definition": "| { equal: true",
          "shape": {
            "type": "primitive",
            "definition": "| { equal: true"
          }
        }
      ],
      "confidence": 0.1
    },
    {
      "shapeKey": "primitive:{\n  input: T",
      "types": [
        {
          "name": "MonadRightUnitWitness",
          "type": "type",
          "file": "src/types/witnesses.ts",
          "line": 94,
          "definition": "{\n  input: T",
          "shape": {
            "type": "primitive",
            "definition": "{\n  input: T"
          }
        },
        {
          "name": "EMUnitMorphismWitness",
          "type": "type",
          "file": "src/types/witnesses.ts",
          "line": 133,
          "definition": "{\n  input: T",
          "shape": {
            "type": "primitive",
            "definition": "{\n  input: T"
          }
        }
      ],
      "confidence": 0.1
    },
    {
      "shapeKey": "primitive:number",
      "types": [
        {
          "name": "ElemId",
          "type": "type",
          "file": "src/algebra/group/iso/CanonicalTable.ts",
          "line": 4,
          "definition": "number",
          "shape": {
            "type": "primitive",
            "definition": "number"
          }
        },
        {
          "name": "Prob",
          "type": "type",
          "file": "src/prob/Dist.ts",
          "line": 4,
          "definition": "number",
          "shape": {
            "type": "primitive",
            "definition": "number"
          }
        },
        {
          "name": "Int",
          "type": "type",
          "file": "src/types/snf-witness.ts",
          "line": 7,
          "definition": "number",
          "shape": {
            "type": "primitive",
            "definition": "number"
          }
        }
      ],
      "confidence": 0.05
    }
  ],
  "allTypes": [
    {
      "name": "Action",
      "type": "interface",
      "file": "src/types/algebraic.ts",
      "line": 78,
      "properties": [
        {
          "name": "act",
          "optional": false,
          "type": "(m: M, a: A) => A"
        },
        {
          "name": "act",
          "optional": false,
          "type": "method",
          "signature": "(m: M, a: A)",
          "returnType": "A"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "act",
            "optional": false,
            "type": "(m: M, a: A) => A"
          },
          {
            "name": "act",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "AdjointEquivalence",
      "type": "interface",
      "file": "src/types/catkit-equivalence.ts",
      "line": 102,
      "properties": [
        {
          "name": "A",
          "optional": false,
          "type": "SmallCategory<A_O,A_M> & Finite<A_O,A_M>"
        },
        {
          "name": "B",
          "optional": false,
          "type": "SmallCategory<B_O,B_M> & Finite<B_O,B_M>"
        },
        {
          "name": "F",
          "optional": false,
          "type": "Functor<A_O,A_M,B_O,B_M>; // A -> B"
        },
        {
          "name": "G",
          "optional": false,
          "type": "Functor<B_O,B_M,A_O,A_M>; // B -> A"
        },
        {
          "name": "unit",
          "optional": false,
          "type": "NatIso<A_O,A_M,A_O,A_M>; // η: Id_A ⇒ G∘F"
        },
        {
          "name": "counit",
          "optional": false,
          "type": "NatIso<B_O,B_M,B_O,B_M>; // ε: F∘G ⇒ Id_B"
        }
      ],
      "shape": {
        "propertyCount": 6,
        "properties": [
          {
            "name": "A",
            "optional": false,
            "type": "SmallCategory<T> & Finite<T>"
          },
          {
            "name": "B",
            "optional": false,
            "type": "SmallCategory<T> & Finite<T>"
          },
          {
            "name": "counit",
            "optional": false,
            "type": "NatIso<T>; // ε: F∘G ⇒ Id_B"
          },
          {
            "name": "F",
            "optional": false,
            "type": "Functor<T>; // A -> B"
          },
          {
            "name": "G",
            "optional": false,
            "type": "Functor<T>; // B -> A"
          },
          {
            "name": "unit",
            "optional": false,
            "type": "NatIso<T>; // η: Id_A ⇒ G∘F"
          }
        ]
      }
    },
    {
      "name": "Adjunction",
      "type": "interface",
      "file": "src/types/catkit-adjunction.ts",
      "line": 57,
      "properties": [
        {
          "name": "A",
          "optional": false,
          "type": "SmallCategory<A_O, A_M>"
        },
        {
          "name": "B",
          "optional": false,
          "type": "SmallCategory<B_O, B_M>"
        },
        {
          "name": "F",
          "optional": false,
          "type": "Functor<A_O, A_M, B_O, B_M>;       // left adjoint"
        },
        {
          "name": "G",
          "optional": false,
          "type": "Functor<B_O, B_M, A_O, A_M>;       // right adjoint"
        },
        {
          "name": "unit",
          "optional": false,
          "type": "Nat<A_O, A_M, A_O, A_M>;       // η : Id_A ⇒ G∘F   (codomain functor should be G∘F)"
        },
        {
          "name": "counit",
          "optional": false,
          "type": "Nat<B_O, B_M, B_O, B_M>;       // ε : F∘G ⇒ Id_B"
        }
      ],
      "shape": {
        "propertyCount": 6,
        "properties": [
          {
            "name": "A",
            "optional": false,
            "type": "SmallCategory<T>"
          },
          {
            "name": "B",
            "optional": false,
            "type": "SmallCategory<T>"
          },
          {
            "name": "counit",
            "optional": false,
            "type": "Nat<T>; // ε : F∘G ⇒ Id_B"
          },
          {
            "name": "F",
            "optional": false,
            "type": "Functor<T>; // left adjoint"
          },
          {
            "name": "G",
            "optional": false,
            "type": "Functor<T>; // right adjoint"
          },
          {
            "name": "unit",
            "optional": false,
            "type": "Nat<T>; // η : Id_A ⇒ G∘F (codomain functor should be G∘F)"
          }
        ]
      }
    },
    {
      "name": "AdjunctionWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 57,
      "definition": "{\n  isAdjunction: boolean",
      "shape": {
        "type": "primitive",
        "definition": "{\n  isAdjunction: boolean"
      }
    },
    {
      "name": "AdvancedPrism",
      "type": "interface",
      "file": "src/types/advanced.ts",
      "line": 337,
      "properties": [
        {
          "name": "getOption",
          "optional": false,
          "type": "(s: S) => A | undefined"
        },
        {
          "name": "getOption",
          "optional": false,
          "type": "method",
          "signature": "(s: S)",
          "returnType": "A | undefined"
        },
        {
          "name": "reverseGet",
          "optional": false,
          "type": "(a: A) => S"
        },
        {
          "name": "reverseGet",
          "optional": false,
          "type": "method",
          "signature": "(a: A)",
          "returnType": "S"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "getOption",
            "optional": false,
            "type": "(s: S) => A | undefined"
          },
          {
            "name": "getOption",
            "optional": false,
            "type": "method"
          },
          {
            "name": "reverseGet",
            "optional": false,
            "type": "(a: A) => S"
          },
          {
            "name": "reverseGet",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "Algebra",
      "type": "interface",
      "file": "src/types/algebraic.ts",
      "line": 85,
      "properties": [
        {
          "name": "fold",
          "optional": false,
          "type": "<A>(ta: HKT<T, A>) => A"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "fold",
            "optional": false,
            "type": "<A>(ta: HKT<T>) => A"
          }
        ]
      }
    },
    {
      "name": "AlgebraHomomorphism",
      "type": "interface",
      "file": "src/types/adt-functor.ts",
      "line": 33,
      "properties": [
        {
          "name": "map",
          "optional": false,
          "type": "(a: A) => B"
        },
        {
          "name": "map",
          "optional": false,
          "type": "method",
          "signature": "(a: A)",
          "returnType": "B"
        },
        {
          "name": "source",
          "optional": false,
          "type": "FunctorAlgebra<F, A>"
        },
        {
          "name": "target",
          "optional": false,
          "type": "FunctorAlgebra<F, B>"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "map",
            "optional": false,
            "type": "(a: A) => B"
          },
          {
            "name": "map",
            "optional": false,
            "type": "method"
          },
          {
            "name": "source",
            "optional": false,
            "type": "FunctorAlgebra<T>"
          },
          {
            "name": "target",
            "optional": false,
            "type": "FunctorAlgebra<T>"
          }
        ]
      }
    },
    {
      "name": "AllegoryLawWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 175,
      "definition": "{\n  lawType: \"dagger-involution\" | \"modular-left\" | \"composition-associativity\"",
      "shape": {
        "type": "primitive",
        "definition": "{\n  lawType: \"dagger-involution\" | \"modular-left\" | \"composition-associativity\""
      }
    },
    {
      "name": "AllegoryWitness",
      "type": "type",
      "file": "src/types/rel-lawcheck-witnessed.ts",
      "line": 36,
      "definition": "{\n  daggerInvolution: LawCheck<{ R: any",
      "shape": {
        "type": "primitive",
        "definition": "{\n  daggerInvolution: LawCheck<{ R: any"
      }
    },
    {
      "name": "AnyOptic",
      "type": "type",
      "file": "src/types/catkit-traversal.ts",
      "line": 155,
      "definition": "<P>(dict: WanderDict<P>) => (pab:any)=> any",
      "shape": {
        "type": "function",
        "signature": "<P>(dict: WanderDict<P>) => (pab:any)=> any"
      }
    },
    {
      "name": "App",
      "type": "type",
      "file": "src/universal/Term.ts",
      "line": 5,
      "definition": "{ tag: \"App\"",
      "shape": {
        "type": "primitive",
        "definition": "{ tag: \"App\""
      }
    },
    {
      "name": "Applicative",
      "type": "interface",
      "file": "src/types/catkit-traversal.ts",
      "line": 10,
      "properties": [
        {
          "name": "of",
          "optional": false,
          "type": "<A>(a:A)=> any; // Box<A>"
        },
        {
          "name": "map",
          "optional": false,
          "type": "<A,B>(fa: any, f:(a:A)=>B)=> any; // Box<A> -> Box<B>"
        },
        {
          "name": "ap",
          "optional": false,
          "type": "<A,B>(ff: any, fa: any)=> any; // Box<(a:A)=>B> -> Box<A> -> Box<B>"
        },
        {
          "name": "liftA2",
          "optional": true,
          "type": "<A,B,C>(f:(a:A,b:B)=>C, fa:any, fb:any)=> any; // Box<A> -> Box<B> -> Box<C>"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "ap",
            "optional": false,
            "type": "<A,B>(ff: any, fa: any)=> any; // Box<T>B> -> Box<T> -> Box<T>"
          },
          {
            "name": "liftA2",
            "optional": true,
            "type": "<A,B,C>(f:(a:A,b:B)=>C, fa:any, fb:any)=> any; // Box<T> -> Box<T> -> Box<T>"
          },
          {
            "name": "map",
            "optional": false,
            "type": "<A,B>(fa: any, f:(a:A)=>B)=> any; // Box<T> -> Box<T>"
          },
          {
            "name": "of",
            "optional": false,
            "type": "<A>(a:A)=> any; // Box<T>"
          }
        ]
      }
    },
    {
      "name": "ApplicativeOps",
      "type": "interface",
      "file": "src/types/freeapp-coyo.ts",
      "line": 65,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "Apply",
      "type": "type",
      "file": "src/category/Lan.ts",
      "line": 22,
      "definition": "H",
      "shape": {
        "type": "primitive",
        "definition": "H"
      }
    },
    {
      "name": "AppMorphism",
      "type": "interface",
      "file": "src/types/catkit-traversal.ts",
      "line": 56,
      "properties": [
        {
          "name": "phi",
          "optional": false,
          "type": "<A>(fa: any) => any; // Box1<A> -> Box2<A>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "phi",
            "optional": false,
            "type": "<A>(fa: any) => any; // Box1<T> -> Box2<T>"
          }
        ]
      }
    },
    {
      "name": "AuditEntry",
      "type": "interface",
      "file": "src/types/quiver-pushout.ts",
      "line": 22,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "Auto",
      "type": "type",
      "file": "src/structures/group/automorphisms/Aut.ts",
      "line": 55,
      "definition": "GroupIso<A, A>",
      "shape": {
        "type": "primitive",
        "definition": "GroupIso<A, A>"
      }
    },
    {
      "name": "BenchmarkConfig",
      "type": "interface",
      "file": "src/bench/rel-benchmark.ts",
      "line": 31,
      "properties": [
        {
          "name": "sizes",
          "optional": false,
          "type": "number[]"
        },
        {
          "name": "densities",
          "optional": false,
          "type": "number[]"
        },
        {
          "name": "iterations",
          "optional": false,
          "type": "number"
        },
        {
          "name": "seed",
          "optional": false,
          "type": "number"
        },
        {
          "name": "outputDir",
          "optional": false,
          "type": "string"
        }
      ],
      "shape": {
        "propertyCount": 5,
        "properties": [
          {
            "name": "densities",
            "optional": false,
            "type": "number[]"
          },
          {
            "name": "iterations",
            "optional": false,
            "type": "number"
          },
          {
            "name": "outputDir",
            "optional": false,
            "type": "string"
          },
          {
            "name": "seed",
            "optional": false,
            "type": "number"
          },
          {
            "name": "sizes",
            "optional": false,
            "type": "number[]"
          }
        ]
      }
    },
    {
      "name": "BenchmarkRun",
      "type": "interface",
      "file": "src/bench/rel-benchmark.ts",
      "line": 49,
      "properties": [
        {
          "name": "timestamp",
          "optional": false,
          "type": "string"
        },
        {
          "name": "config",
          "optional": false,
          "type": "BenchmarkConfig"
        },
        {
          "name": "results",
          "optional": false,
          "type": "OperationResult[]"
        },
        {
          "name": "summary",
          "optional": false,
          "type": "{"
        },
        {
          "name": "totalTests",
          "optional": false,
          "type": "number"
        },
        {
          "name": "averageSpeedup",
          "optional": false,
          "type": "Record<string, number>"
        },
        {
          "name": "medianSpeedup",
          "optional": false,
          "type": "Record<string, number>"
        }
      ],
      "shape": {
        "propertyCount": 7,
        "properties": [
          {
            "name": "averageSpeedup",
            "optional": false,
            "type": "Record<T>"
          },
          {
            "name": "config",
            "optional": false,
            "type": "BenchmarkConfig"
          },
          {
            "name": "medianSpeedup",
            "optional": false,
            "type": "Record<T>"
          },
          {
            "name": "results",
            "optional": false,
            "type": "OperationResult[]"
          },
          {
            "name": "summary",
            "optional": false,
            "type": "{"
          },
          {
            "name": "timestamp",
            "optional": false,
            "type": "string"
          },
          {
            "name": "totalTests",
            "optional": false,
            "type": "number"
          }
        ]
      }
    },
    {
      "name": "BFin",
      "type": "type",
      "file": "src/gadt/basic/BFin.ts",
      "line": 34,
      "definition": "HFix<BFinF<any, A>, A>",
      "shape": {
        "type": "primitive",
        "definition": "HFix<BFinF<any, A>, A>"
      }
    },
    {
      "name": "BFinF",
      "type": "type",
      "file": "src/gadt/basic/BFin.ts",
      "line": 20,
      "definition": "| { _t: \"zero\"",
      "shape": {
        "type": "primitive",
        "definition": "| { _t: \"zero\""
      }
    },
    {
      "name": "Bicategory",
      "type": "interface",
      "file": "src/types/bicategory.ts",
      "line": 3,
      "properties": [
        {
          "name": "id1",
          "optional": false,
          "type": "(A: Obj) => One"
        },
        {
          "name": "id1",
          "optional": false,
          "type": "method",
          "signature": "(A: Obj)",
          "returnType": "One"
        },
        {
          "name": "comp1",
          "optional": false,
          "type": "(g: One, f: One) => One"
        },
        {
          "name": "comp1",
          "optional": false,
          "type": "method",
          "signature": "(g: One, f: One)",
          "returnType": "One"
        },
        {
          "name": "id2",
          "optional": false,
          "type": "(f: One) => Two"
        },
        {
          "name": "id2",
          "optional": false,
          "type": "method",
          "signature": "(f: One)",
          "returnType": "Two"
        },
        {
          "name": "vcomp",
          "optional": false,
          "type": "(beta: Two, alpha: Two) => Two"
        },
        {
          "name": "vcomp",
          "optional": false,
          "type": "method",
          "signature": "(beta: Two, alpha: Two)",
          "returnType": "Two"
        },
        {
          "name": "whiskerL",
          "optional": false,
          "type": "(F: One, alpha: Two) => Two"
        },
        {
          "name": "whiskerL",
          "optional": false,
          "type": "method",
          "signature": "(F: One, alpha: Two)",
          "returnType": "Two"
        },
        {
          "name": "whiskerR",
          "optional": false,
          "type": "(alpha: Two, G: One) => Two"
        },
        {
          "name": "whiskerR",
          "optional": false,
          "type": "method",
          "signature": "(alpha: Two, G: One)",
          "returnType": "Two"
        }
      ],
      "shape": {
        "propertyCount": 12,
        "properties": [
          {
            "name": "comp1",
            "optional": false,
            "type": "(g: One, f: One) => One"
          },
          {
            "name": "comp1",
            "optional": false,
            "type": "method"
          },
          {
            "name": "id1",
            "optional": false,
            "type": "(A: Obj) => One"
          },
          {
            "name": "id1",
            "optional": false,
            "type": "method"
          },
          {
            "name": "id2",
            "optional": false,
            "type": "(f: One) => Two"
          },
          {
            "name": "id2",
            "optional": false,
            "type": "method"
          },
          {
            "name": "vcomp",
            "optional": false,
            "type": "(beta: Two, alpha: Two) => Two"
          },
          {
            "name": "vcomp",
            "optional": false,
            "type": "method"
          },
          {
            "name": "whiskerL",
            "optional": false,
            "type": "(F: One, alpha: Two) => Two"
          },
          {
            "name": "whiskerL",
            "optional": false,
            "type": "method"
          },
          {
            "name": "whiskerR",
            "optional": false,
            "type": "(alpha: Two, G: One) => Two"
          },
          {
            "name": "whiskerR",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "Bifunctor",
      "type": "interface",
      "file": "src/types/functors.ts",
      "line": 24,
      "properties": [
        {
          "name": "bimap",
          "optional": false,
          "type": "<E, A, E2, A2>(fea: HKT2<F, E, A>, f: (e: E) => E2, g: (a: A) => A2) => HKT2<F, E2, A2>"
        },
        {
          "name": "mapLeft",
          "optional": true,
          "type": "<E, E2, A>(fea: HKT2<F, E, A>, f: (e: E) => E2) => HKT2<F, E2, A>"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "bimap",
            "optional": false,
            "type": "<E, A, E2, A2>(fea: HKT2<T>, f: (e: E) => E2, g: (a: A) => A2) => HKT2<T>"
          },
          {
            "name": "mapLeft",
            "optional": true,
            "type": "<E, E2, A>(fea: HKT2<T>, f: (e: E) => E2) => HKT2<T>"
          }
        ]
      }
    },
    {
      "name": "BifunctorLegacy",
      "type": "interface",
      "file": "src/types/functors.ts",
      "line": 37,
      "properties": [
        {
          "name": "bimap",
          "optional": false,
          "type": "<A, B, C, D>(fab: HKT<F, [A, B]>, f: (a: A) => C, g: (b: B) => D) => HKT<F, [C, D]>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "bimap",
            "optional": false,
            "type": "<A, B, C, D>(fab: HKT<T>, f: (a: A) => C, g: (b: B) => D) => HKT<T>"
          }
        ]
      }
    },
    {
      "name": "Bijection",
      "type": "type",
      "file": "src/types/double-functor.ts",
      "line": 108,
      "definition": "{ forth: Fun<A,B>",
      "shape": {
        "type": "primitive",
        "definition": "{ forth: Fun<A,B>"
      }
    },
    {
      "name": "BinaryTree",
      "type": "type",
      "file": "src/types/adt-tree.ts",
      "line": 21,
      "definition": "Fix<BinaryTreeF<any, A>>",
      "shape": {
        "type": "primitive",
        "definition": "Fix<BinaryTreeF<any, A>>"
      }
    },
    {
      "name": "BinaryTreeF",
      "type": "type",
      "file": "src/types/adt-tree.ts",
      "line": 7,
      "definition": "Sum<A, Pair<X, X>>",
      "shape": {
        "type": "primitive",
        "definition": "Sum<A, Pair<X, X>>"
      }
    },
    {
      "name": "Bit",
      "type": "type",
      "file": "src/types/finvect.ts",
      "line": 3,
      "definition": "0 | 1",
      "shape": {
        "type": "primitive",
        "definition": "0 | 1"
      }
    },
    {
      "name": "Bounce",
      "type": "type",
      "file": "src/types/cont.ts",
      "line": 169,
      "definition": "| { tag: 'Done', value: A }\n  | { tag: 'More', thunk: () => Bounce<A> }",
      "shape": {
        "type": "function",
        "signature": "| { tag: 'Done', value: A }\n  | { tag: 'More', thunk: () => Bounce<A> }"
      }
    },
    {
      "name": "BoundedLattice",
      "type": "type",
      "file": "src/order/Lattice.ts",
      "line": 9,
      "definition": "Lattice<A> & { top: A",
      "shape": {
        "type": "primitive",
        "definition": "Lattice<A> & { top: A"
      }
    },
    {
      "name": "C",
      "type": "type",
      "file": "src/structures/group/Complex.ts",
      "line": 1,
      "definition": "{ re: number",
      "shape": {
        "type": "primitive",
        "definition": "{ re: number"
      }
    },
    {
      "name": "CapturedCont",
      "type": "type",
      "file": "src/types/shift-reset.ts",
      "line": 13,
      "definition": "(a: A) => Cont<R, R>",
      "shape": {
        "type": "function",
        "signature": "(a: A) => Cont<R, R>"
      }
    },
    {
      "name": "Category",
      "type": "interface",
      "file": "src/types/catkit-comma-categories.ts",
      "line": 17,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "CategoryFunctor",
      "type": "interface",
      "file": "src/types/category-to-nerve-sset.ts",
      "line": 55,
      "properties": [
        {
          "name": "Fobj",
          "optional": false,
          "type": "(o: C_O) => D_O"
        },
        {
          "name": "Fobj",
          "optional": false,
          "type": "method",
          "signature": "(o: C_O)",
          "returnType": "D_O"
        },
        {
          "name": "Fmor",
          "optional": false,
          "type": "(m: C_M) => D_M; // must preserve identity & composition (not enforced by TS)"
        },
        {
          "name": "Fmor",
          "optional": false,
          "type": "method",
          "signature": "(m: C_M)",
          "returnType": "D_M; // must preserve identity & composition (not enforced by TS)"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "Fmor",
            "optional": false,
            "type": "(m: C_M) => D_M; // must preserve identity & composition (not enforced by TS)"
          },
          {
            "name": "Fmor",
            "optional": false,
            "type": "method"
          },
          {
            "name": "Fobj",
            "optional": false,
            "type": "(o: C_O) => D_O"
          },
          {
            "name": "Fobj",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "CayleyTable",
      "type": "type",
      "file": "src/algebra/group/iso/CanonicalTable.ts",
      "line": 5,
      "definition": "number[][]",
      "shape": {
        "type": "primitive",
        "definition": "number[][]"
      }
    },
    {
      "name": "ChainComplex02",
      "type": "type",
      "file": "src/types/sset-quasicat.ts",
      "line": 526,
      "definition": "{\n  C0: Obj[]",
      "shape": {
        "type": "primitive",
        "definition": "{\n  C0: Obj[]"
      }
    },
    {
      "name": "Coalgebra",
      "type": "interface",
      "file": "src/types/algebraic.ts",
      "line": 91,
      "properties": [
        {
          "name": "unfold",
          "optional": false,
          "type": "<A>(a: A) => HKT<W, A>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "unfold",
            "optional": false,
            "type": "<A>(a: A) => HKT<T>"
          }
        ]
      }
    },
    {
      "name": "CodensityAssumptions",
      "type": "type",
      "file": "src/types/codensity-of.ts",
      "line": 24,
      "definition": "{\n  smallDomain?: boolean",
      "shape": {
        "type": "primitive",
        "definition": "{\n  smallDomain?: boolean"
      }
    },
    {
      "name": "CodensityMonad",
      "type": "interface",
      "file": "src/types/codensity-set.ts",
      "line": 24,
      "properties": [
        {
          "name": "T",
          "optional": false,
          "type": "SetValuedFunctor<any, any>"
        },
        {
          "name": "eta",
          "optional": false,
          "type": "<A>(Aset: SetObj<A>) => (a: A) => any; // A → T^G(A) (unit)"
        },
        {
          "name": "mu",
          "optional": false,
          "type": "<A>(Aset: SetObj<A>) => (tt: any) => any; // T^G(T^G(A)) → T^G(A) (multiplication)"
        }
      ],
      "shape": {
        "propertyCount": 3,
        "properties": [
          {
            "name": "eta",
            "optional": false,
            "type": "<A>(Aset: SetObj<T>) => (a: A) => any; // A → T^G(A) (unit)"
          },
          {
            "name": "mu",
            "optional": false,
            "type": "<A>(Aset: SetObj<T>) => (tt: any) => any; // T^G(T^G(A)) → T^G(A) (multiplication)"
          },
          {
            "name": "T",
            "optional": false,
            "type": "SetValuedFunctor<T>"
          }
        ]
      }
    },
    {
      "name": "CodensityMonadOps",
      "type": "interface",
      "file": "src/types/codensity-monad.ts",
      "line": 19,
      "properties": [
        {
          "name": "T",
          "optional": false,
          "type": "SetFunctor<any, any>"
        },
        {
          "name": "eta",
          "optional": false,
          "type": "<A>(Aset: SetObj<A>) => (a: A) => any"
        },
        {
          "name": "mu",
          "optional": false,
          "type": "<A>(Aset: SetObj<A>) => (tt: any) => any"
        },
        {
          "name": "of",
          "optional": false,
          "type": "<A>(Aset: SetObj<A>) => (a: A) => any"
        },
        {
          "name": "map",
          "optional": false,
          "type": "<A, B>(Aset: SetObj<A>, Bset: SetObj<B>) => (f: (a: A) => B) => (tA: any) => any"
        },
        {
          "name": "chain",
          "optional": false,
          "type": "<A, B>(Aset: SetObj<A>, Bset: SetObj<B>) => (k: (a: A) => any) => (tA: any) => any"
        },
        {
          "name": "ap",
          "optional": false,
          "type": "<A, B>(Aset: SetObj<A>, Bset: SetObj<B>) => (tF: any) => (tA: any) => any"
        },
        {
          "name": "run",
          "optional": false,
          "type": "<A>(Aset: SetObj<A>) => (tA: any) => (k: (a: A) => any) => any"
        },
        {
          "name": "pure",
          "optional": false,
          "type": "<A>(Aset: SetObj<A>) => (a: A) => any; // Alias for of"
        }
      ],
      "shape": {
        "propertyCount": 9,
        "properties": [
          {
            "name": "ap",
            "optional": false,
            "type": "<A, B>(Aset: SetObj<T>, Bset: SetObj<T>) => (tF: any) => (tA: any) => any"
          },
          {
            "name": "chain",
            "optional": false,
            "type": "<A, B>(Aset: SetObj<T>, Bset: SetObj<T>) => (k: (a: A) => any) => (tA: any) => any"
          },
          {
            "name": "eta",
            "optional": false,
            "type": "<A>(Aset: SetObj<T>) => (a: A) => any"
          },
          {
            "name": "map",
            "optional": false,
            "type": "<A, B>(Aset: SetObj<T>, Bset: SetObj<T>) => (f: (a: A) => B) => (tA: any) => any"
          },
          {
            "name": "mu",
            "optional": false,
            "type": "<A>(Aset: SetObj<T>) => (tt: any) => any"
          },
          {
            "name": "of",
            "optional": false,
            "type": "<A>(Aset: SetObj<T>) => (a: A) => any"
          },
          {
            "name": "pure",
            "optional": false,
            "type": "<A>(Aset: SetObj<T>) => (a: A) => any; // Alias for of"
          },
          {
            "name": "run",
            "optional": false,
            "type": "<A>(Aset: SetObj<T>) => (tA: any) => (k: (a: A) => any) => any"
          },
          {
            "name": "T",
            "optional": false,
            "type": "SetFunctor<T>"
          }
        ]
      }
    },
    {
      "name": "CodensityNat",
      "type": "interface",
      "file": "src/types/codensity-nat-view.ts",
      "line": 79,
      "properties": [
        {
          "name": "source",
          "optional": false,
          "type": "SetFunctor<B_O, B_M>; // G^A"
        },
        {
          "name": "target",
          "optional": false,
          "type": "SetFunctor<B_O, B_M>; // G"
        },
        {
          "name": "at",
          "optional": false,
          "type": "(b: B_O) => (k: (a: A) => any) => any"
        },
        {
          "name": "at",
          "optional": false,
          "type": "method",
          "signature": "(b: B_O)",
          "returnType": "(k: (a: A) => any) => any"
        },
        {
          "name": "checkNaturality",
          "optional": false,
          "type": "(B: SmallCategory<B_O, B_M> & { morphisms: ReadonlyArray<B_M>"
        }
      ],
      "shape": {
        "propertyCount": 5,
        "properties": [
          {
            "name": "at",
            "optional": false,
            "type": "(b: B_O) => (k: (a: A) => any) => any"
          },
          {
            "name": "at",
            "optional": false,
            "type": "method"
          },
          {
            "name": "checkNaturality",
            "optional": false,
            "type": "(B: SmallCategory<T> & { morphisms: ReadonlyB_M[]"
          },
          {
            "name": "source",
            "optional": false,
            "type": "SetFunctor<T>; // G^A"
          },
          {
            "name": "target",
            "optional": false,
            "type": "SetFunctor<T>; // G"
          }
        ]
      }
    },
    {
      "name": "CodensityNatPack",
      "type": "type",
      "file": "src/laws/examples/CodensityNat.ts",
      "line": 10,
      "definition": "{\n  to:   (tga:TGA)=> Nat<GA<A>, G<A>>",
      "shape": {
        "type": "function",
        "signature": "{\n  to:   (tga:TGA)=> Nat<GA<A>, G<A>>"
      }
    },
    {
      "name": "CoequalizerResult",
      "type": "interface",
      "file": "src/types/quiver-pushout.ts",
      "line": 41,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "ColimAtCState",
      "type": "type",
      "file": "src/types/pointwise-colim-util.ts",
      "line": 10,
      "definition": "{\n  S0: SetObj<any>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  S0: SetObj<any>"
      }
    },
    {
      "name": "CommaMor",
      "type": "type",
      "file": "src/types/catkit-comma-categories.ts",
      "line": 43,
      "definition": "{\n  readonly f: AMor",
      "shape": {
        "type": "primitive",
        "definition": "{\n  readonly f: AMor"
      }
    },
    {
      "name": "CommaObj",
      "type": "type",
      "file": "src/types/catkit-comma-categories.ts",
      "line": 36,
      "definition": "{\n  readonly a: AObj",
      "shape": {
        "type": "primitive",
        "definition": "{\n  readonly a: AObj"
      }
    },
    {
      "name": "CompleteLattice",
      "type": "type",
      "file": "src/order/Lattice.ts",
      "line": 12,
      "definition": "BoundedLattice<A> & {\n  sup: (S:A[])=>A",
      "shape": {
        "type": "function",
        "signature": "BoundedLattice<A> & {\n  sup: (S:A[])=>A"
      }
    },
    {
      "name": "Compose",
      "type": "type",
      "file": "src/types/catkit-traversal.ts",
      "line": 40,
      "definition": "{ tag:\"Compose\", value: any }",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "tag",
            "optional": false,
            "type": "\"Compose\", value: any"
          }
        ]
      }
    },
    {
      "name": "CompositeOpticsWitness",
      "type": "type",
      "file": "src/types/optics-witness.ts",
      "line": 197,
      "definition": "{\n  lensComposition: LensWitness<S, B>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  lensComposition: LensWitness<S, B>"
      }
    },
    {
      "name": "ComprehensiveLawReport",
      "type": "type",
      "file": "src/types/rel-lawcheck-witnessed.ts",
      "line": 42,
      "definition": "{\n  residualAdjunctions: ResidualAdjunctionWitness",
      "shape": {
        "type": "primitive",
        "definition": "{\n  residualAdjunctions: ResidualAdjunctionWitness"
      }
    },
    {
      "name": "Congruence",
      "type": "interface",
      "file": "src/algebra/group/Congruence.ts",
      "line": 5,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "Const",
      "type": "type",
      "file": "src/types/catkit-traversal.ts",
      "line": 28,
      "definition": "{ tag:\"Const\", value:M }",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "tag",
            "optional": false,
            "type": "\"Const\", value:M"
          }
        ]
      }
    },
    {
      "name": "Cont",
      "type": "type",
      "file": "src/types/cont.ts",
      "line": 9,
      "definition": "(k: (a: A) => R) => R",
      "shape": {
        "type": "function",
        "signature": "(k: (a: A) => R) => R"
      }
    },
    {
      "name": "ContHKT",
      "type": "type",
      "file": "src/types/cont.ts",
      "line": 20,
      "definition": "HKT<'Cont', A>",
      "shape": {
        "type": "primitive",
        "definition": "HKT<'Cont', A>"
      }
    },
    {
      "name": "Contravariant",
      "type": "interface",
      "file": "src/types/functors.ts",
      "line": 14,
      "properties": [
        {
          "name": "contramap",
          "optional": false,
          "type": "<A, B>(fa: HKT<F, A>, f: (b: B) => A) => HKT<F, B>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "contramap",
            "optional": false,
            "type": "<A, B>(fa: HKT<T>, f: (b: B) => A) => HKT<T>"
          }
        ]
      }
    },
    {
      "name": "Copresheaf",
      "type": "interface",
      "file": "src/types/copresheaf.ts",
      "line": 12,
      "properties": [
        {
          "name": "onObj",
          "optional": false,
          "type": "(c: Obj<C>) => SetObj<any>"
        },
        {
          "name": "onObj",
          "optional": false,
          "type": "method",
          "signature": "(c: Obj<C>)",
          "returnType": "SetObj<any>"
        },
        {
          "name": "onMor",
          "optional": false,
          "type": "(f: Mor<C>) => (x: any) => any; // G(f): G(a) -> G(b)"
        },
        {
          "name": "onMor",
          "optional": false,
          "type": "method",
          "signature": "(f: Mor<C>)",
          "returnType": "(x: any) => any; // G(f): G(a) -> G(b)"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "onMor",
            "optional": false,
            "type": "(f: Mor<T>) => (x: any) => any; // G(f): G(a) -> G(b)"
          },
          {
            "name": "onMor",
            "optional": false,
            "type": "method"
          },
          {
            "name": "onObj",
            "optional": false,
            "type": "(c: Obj<T>) => SetObj<T>"
          },
          {
            "name": "onObj",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "Coset",
      "type": "type",
      "file": "src/structures/group/Quotient.ts",
      "line": 5,
      "definition": "{ rep: A }",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "rep",
            "optional": false,
            "type": "A"
          }
        ]
      }
    },
    {
      "name": "Coyoneda",
      "type": "type",
      "file": "src/types/freeapp-coyo.ts",
      "line": 11,
      "definition": "{ fi: F",
      "shape": {
        "type": "primitive",
        "definition": "{ fi: F"
      }
    },
    {
      "name": "CPO",
      "type": "type",
      "file": "src/order/Domain.ts",
      "line": 7,
      "definition": "Poset<A> & {\n  bot: A",
      "shape": {
        "type": "primitive",
        "definition": "Poset<A> & {\n  bot: A"
      }
    },
    {
      "name": "CurriedLens",
      "type": "interface",
      "file": "src/types/advanced.ts",
      "line": 332,
      "properties": [
        {
          "name": "get",
          "optional": false,
          "type": "(s: S) => A"
        },
        {
          "name": "get",
          "optional": false,
          "type": "method",
          "signature": "(s: S)",
          "returnType": "A"
        },
        {
          "name": "set",
          "optional": false,
          "type": "(a: A) => (s: S) => S"
        },
        {
          "name": "set",
          "optional": false,
          "type": "method",
          "signature": "(a: A)",
          "returnType": "(s: S) => S"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "get",
            "optional": false,
            "type": "(s: S) => A"
          },
          {
            "name": "get",
            "optional": false,
            "type": "method"
          },
          {
            "name": "set",
            "optional": false,
            "type": "(a: A) => (s: S) => S"
          },
          {
            "name": "set",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "DelimCont",
      "type": "type",
      "file": "src/types/shift-reset.ts",
      "line": 10,
      "definition": "Cont<R, A>",
      "shape": {
        "type": "primitive",
        "definition": "Cont<R, A>"
      }
    },
    {
      "name": "DiagonalExplanation",
      "type": "interface",
      "file": "src/types/snf-surface-api.ts",
      "line": 26,
      "properties": [
        {
          "name": "rank",
          "optional": false,
          "type": "number;                    // Number of free generators (nonzero diagonal entries)"
        },
        {
          "name": "torsionFactors",
          "optional": false,
          "type": "number[];       // Torsion elements (absolute values of nonzero, non-unit entries)"
        },
        {
          "name": "freeRank",
          "optional": false,
          "type": "number;               // Same as rank, but clearer naming"
        },
        {
          "name": "hasTorsion",
          "optional": false,
          "type": "boolean;            // Whether there are torsion elements"
        },
        {
          "name": "prettyForm",
          "optional": false,
          "type": "string;             // Human-readable group description"
        },
        {
          "name": "betti",
          "optional": false,
          "type": "number;                  // Betti number (rank)"
        }
      ],
      "shape": {
        "propertyCount": 6,
        "properties": [
          {
            "name": "betti",
            "optional": false,
            "type": "number; // Betti number (rank)"
          },
          {
            "name": "freeRank",
            "optional": false,
            "type": "number; // Same as rank, but clearer naming"
          },
          {
            "name": "hasTorsion",
            "optional": false,
            "type": "boolean; // Whether there are torsion elements"
          },
          {
            "name": "prettyForm",
            "optional": false,
            "type": "string; // Human-readable group description"
          },
          {
            "name": "rank",
            "optional": false,
            "type": "number; // Number of free generators (nonzero diagonal entries)"
          },
          {
            "name": "torsionFactors",
            "optional": false,
            "type": "number[]; // Torsion elements (absolute values of nonzero, non-unit entries)"
          }
        ]
      }
    },
    {
      "name": "DiagramToFinSet",
      "type": "interface",
      "file": "src/types/diagram.ts",
      "line": 10,
      "properties": [
        {
          "name": "shape",
          "optional": false,
          "type": "SmallCategory<any, any>"
        },
        {
          "name": "functor",
          "optional": false,
          "type": "SetFunctor<any, any>"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "functor",
            "optional": false,
            "type": "SetFunctor<T>"
          },
          {
            "name": "shape",
            "optional": false,
            "type": "SmallCategory<T>"
          }
        ]
      }
    },
    {
      "name": "Digit",
      "type": "type",
      "file": "src/types/fingertree.ts",
      "line": 18,
      "definition": "| { tag: \"One\"",
      "shape": {
        "type": "primitive",
        "definition": "| { tag: \"One\""
      }
    },
    {
      "name": "DinaturalityTransport",
      "type": "type",
      "file": "src/types/ran-set.ts",
      "line": 34,
      "definition": "{\n  leftToRight: (phi_c: FunctionSpace<D_M, any>) => FunctionSpace<D_M, any>",
      "shape": {
        "type": "function",
        "signature": "{\n  leftToRight: (phi_c: FunctionSpace<D_M, any>) => FunctionSpace<D_M, any>"
      }
    },
    {
      "name": "Dist",
      "type": "type",
      "file": "src/prob/Dist.ts",
      "line": 7,
      "definition": "Array<{ x: A",
      "shape": {
        "type": "primitive",
        "definition": "Array<{ x: A"
      }
    },
    {
      "name": "Doc",
      "type": "type",
      "file": "src/types/freeapp-coyo.ts",
      "line": 159,
      "definition": "{ _doc: string[]",
      "shape": {
        "type": "primitive",
        "definition": "{ _doc: string[]"
      }
    },
    {
      "name": "DoubleCategory",
      "type": "interface",
      "file": "src/types/double-lax-functor.ts",
      "line": 25,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "DoubleFunctor",
      "type": "interface",
      "file": "src/types/category-to-nerve-sset.ts",
      "line": 684,
      "properties": [
        {
          "name": "FH",
          "optional": false,
          "type": "CategoryFunctor<C1_O, C1_H, C2_O, C2_H>;               // on horizontal arrows"
        },
        {
          "name": "FV",
          "optional": false,
          "type": "CategoryFunctor<C1_O, C1_V, C2_O, C2_V>;               // on vertical arrows"
        },
        {
          "name": "onSquare",
          "optional": false,
          "type": "(s: C1_S) => C2_S;                       // action on 2-cells"
        },
        {
          "name": "onSquare",
          "optional": false,
          "type": "method",
          "signature": "(s: C1_S)",
          "returnType": "C2_S;                       // action on 2-cells"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "FH",
            "optional": false,
            "type": "CategoryFunctor<T>; // on horizontal arrows"
          },
          {
            "name": "FV",
            "optional": false,
            "type": "CategoryFunctor<T>; // on vertical arrows"
          },
          {
            "name": "onSquare",
            "optional": false,
            "type": "(s: C1_S) => C2_S; // action on 2-cells"
          },
          {
            "name": "onSquare",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "DoubleLaxFunctor",
      "type": "interface",
      "file": "src/types/double-lax-functor.ts",
      "line": 14,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "DoubleNaturalTransformation",
      "type": "interface",
      "file": "src/types/double-lax-functor.ts",
      "line": 84,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "Edge",
      "type": "type",
      "file": "src/types/sset-quasicat.ts",
      "line": 11,
      "definition": "{\n  key:string",
      "shape": {
        "type": "primitive",
        "definition": "{\n  key:string"
      }
    },
    {
      "name": "EdgeLabel",
      "type": "type",
      "file": "src/types/quiver-pushout.ts",
      "line": 14,
      "definition": "string",
      "shape": {
        "type": "primitive",
        "definition": "string"
      }
    },
    {
      "name": "Either",
      "type": "type",
      "file": "src/types/hkt.ts",
      "line": 29,
      "definition": "{ _tag: 'Left'",
      "shape": {
        "type": "primitive",
        "definition": "{ _tag: 'Left'"
      }
    },
    {
      "name": "EitherFree",
      "type": "type",
      "file": "src/types/optics-free.ts",
      "line": 26,
      "definition": "| { _tag: 'Left'",
      "shape": {
        "type": "primitive",
        "definition": "| { _tag: 'Left'"
      }
    },
    {
      "name": "ElemId",
      "type": "type",
      "file": "src/algebra/group/iso/CanonicalTable.ts",
      "line": 4,
      "definition": "number",
      "shape": {
        "type": "primitive",
        "definition": "number"
      }
    },
    {
      "name": "EMAlgebra",
      "type": "interface",
      "file": "src/types/strong-monad.ts",
      "line": 141,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "EMAlgebraUnitWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 118,
      "definition": "{\n  input: A",
      "shape": {
        "type": "primitive",
        "definition": "{\n  input: A"
      }
    },
    {
      "name": "EMMonoidLawResults",
      "type": "type",
      "file": "src/types/strong-monad.ts",
      "line": 389,
      "definition": "{\n  monoidLaws: LawCheck<{ a: A",
      "shape": {
        "type": "primitive",
        "definition": "{\n  monoidLaws: LawCheck<{ a: A"
      }
    },
    {
      "name": "EMMonoidWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 78,
      "definition": "{\n  monoidLaws: LawCheck<{ a: A",
      "shape": {
        "type": "primitive",
        "definition": "{\n  monoidLaws: LawCheck<{ a: A"
      }
    },
    {
      "name": "EMMultiplicativityWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 125,
      "definition": "{\n  ta: T",
      "shape": {
        "type": "primitive",
        "definition": "{\n  ta: T"
      }
    },
    {
      "name": "EMUnitMorphismWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 133,
      "definition": "{\n  input: T",
      "shape": {
        "type": "primitive",
        "definition": "{\n  input: T"
      }
    },
    {
      "name": "EndFamily",
      "type": "type",
      "file": "src/types/ran-set.ts",
      "line": 28,
      "definition": "Record<string, FunctionSpace<D_M, any>> & {\n  readonly __objects: ReadonlyArray<C_O>",
      "shape": {
        "type": "primitive",
        "definition": "Record<string, FunctionSpace<D_M, any>> & {\n  readonly __objects: ReadonlyArray<C_O>"
      }
    },
    {
      "name": "Endofunctor",
      "type": "interface",
      "file": "src/types/adt-functor.ts",
      "line": 7,
      "properties": [
        {
          "name": "fmap",
          "optional": false,
          "type": "<Y>(f: (x: X) => Y) => Endofunctor<Y>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "fmap",
            "optional": false,
            "type": "<Y>(f: (x: X) => Y) => Endofunctor<T>"
          }
        ]
      }
    },
    {
      "name": "EnhancedCongruence",
      "type": "interface",
      "file": "src/algebra/group/EnhancedCongruence.ts",
      "line": 7,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "EnhancedFiniteGroup",
      "type": "interface",
      "file": "src/algebra/group/EnhancedQuotientGroup.ts",
      "line": 7,
      "properties": [
        {
          "name": "show",
          "optional": true,
          "type": "(a:G)=>string"
        },
        {
          "name": "show",
          "optional": true,
          "type": "method",
          "signature": "(a:G)",
          "returnType": "string"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "show",
            "optional": true,
            "type": "(a:G)=>string"
          },
          {
            "name": "show",
            "optional": true,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "EnhancedGroupHom",
      "type": "interface",
      "file": "src/algebra/group/EnhancedGroup.ts",
      "line": 9,
      "properties": [
        {
          "name": "quotient",
          "optional": false,
          "type": "EnhancedFiniteGroup<{rep:G"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "quotient",
            "optional": false,
            "type": "EnhancedFiniteGroup<{rep:G"
          }
        ]
      }
    },
    {
      "name": "EnhancedQuotient",
      "type": "interface",
      "file": "src/algebra/group/EnhancedQuotientGroup.ts",
      "line": 16,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "Env",
      "type": "type",
      "file": "src/types/freeapp-coyo.ts",
      "line": 141,
      "definition": "Record<string, string>",
      "shape": {
        "type": "primitive",
        "definition": "Record<string, string>"
      }
    },
    {
      "name": "Eq",
      "type": "type",
      "file": "src/types/eq.ts",
      "line": 1,
      "definition": "(x: T, y: T) => boolean",
      "shape": {
        "type": "function",
        "signature": "(x: T, y: T) => boolean"
      }
    },
    {
      "name": "Equation",
      "type": "type",
      "file": "src/universal/Equation.ts",
      "line": 5,
      "definition": "{ lhs: Term",
      "shape": {
        "type": "primitive",
        "definition": "{ lhs: Term"
      }
    },
    {
      "name": "Equiv",
      "type": "type",
      "file": "src/algebra/group/EnhancedCongruence.ts",
      "line": 5,
      "definition": "(x: G, y: G) => boolean",
      "shape": {
        "type": "function",
        "signature": "(x: G, y: G) => boolean"
      }
    },
    {
      "name": "EquivalenceWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 38,
      "definition": "| { isEquivalent: true }\n  | { isEquivalent: false",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "isEquivalent",
            "optional": false,
            "type": "true"
          }
        ]
      }
    },
    {
      "name": "EqWit",
      "type": "interface",
      "file": "src/gadt/Reduction.ts",
      "line": 8,
      "properties": [
        {
          "name": "cast",
          "optional": false,
          "type": "(a: A) => B"
        },
        {
          "name": "cast",
          "optional": false,
          "type": "method",
          "signature": "(a: A)",
          "returnType": "B"
        },
        {
          "name": "sym",
          "optional": false,
          "type": "() => EqWit<B, A>"
        },
        {
          "name": "sym",
          "optional": false,
          "type": "method",
          "signature": "()",
          "returnType": "EqWit<B, A>"
        },
        {
          "name": "andThen",
          "optional": false,
          "type": "<C>(next: EqWit<B, C>) => EqWit<A, C>"
        }
      ],
      "shape": {
        "propertyCount": 5,
        "properties": [
          {
            "name": "andThen",
            "optional": false,
            "type": "<C>(next: EqWit<T>) => EqWit<T>"
          },
          {
            "name": "cast",
            "optional": false,
            "type": "(a: A) => B"
          },
          {
            "name": "cast",
            "optional": false,
            "type": "method"
          },
          {
            "name": "sym",
            "optional": false,
            "type": "() => EqWit<T>"
          },
          {
            "name": "sym",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "ExistingOptic",
      "type": "interface",
      "file": "src/types/optics-rewrite-bridge.ts",
      "line": 19,
      "properties": [
        {
          "name": "view",
          "optional": true,
          "type": "(s: S) => A"
        },
        {
          "name": "view",
          "optional": true,
          "type": "method",
          "signature": "(s: S)",
          "returnType": "A"
        },
        {
          "name": "preview",
          "optional": true,
          "type": "(s: S) => A | undefined"
        },
        {
          "name": "preview",
          "optional": true,
          "type": "method",
          "signature": "(s: S)",
          "returnType": "A | undefined"
        },
        {
          "name": "over",
          "optional": false,
          "type": "(f: (a: A) => A) => (s: S) => S"
        },
        {
          "name": "over",
          "optional": false,
          "type": "method",
          "signature": "(f: (a: A)",
          "returnType": "A) => (s: S) => S"
        }
      ],
      "shape": {
        "propertyCount": 6,
        "properties": [
          {
            "name": "over",
            "optional": false,
            "type": "(f: (a: A) => A) => (s: S) => S"
          },
          {
            "name": "over",
            "optional": false,
            "type": "method"
          },
          {
            "name": "preview",
            "optional": true,
            "type": "(s: S) => A | undefined"
          },
          {
            "name": "preview",
            "optional": true,
            "type": "method"
          },
          {
            "name": "view",
            "optional": true,
            "type": "(s: S) => A"
          },
          {
            "name": "view",
            "optional": true,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "Exists",
      "type": "type",
      "file": "src/gadt/Reduction.ts",
      "line": 26,
      "definition": "{ readonly _exists: true",
      "shape": {
        "type": "primitive",
        "definition": "{ readonly _exists: true"
      }
    },
    {
      "name": "Expr",
      "type": "type",
      "file": "src/types/gadt-expr.ts",
      "line": 17,
      "definition": "| { tag: \"num\"",
      "shape": {
        "type": "primitive",
        "definition": "| { tag: \"num\""
      }
    },
    {
      "name": "ExprF",
      "type": "type",
      "file": "src/types/optics-rewrite.ts",
      "line": 48,
      "definition": "| { tag: \"Lit\"",
      "shape": {
        "type": "primitive",
        "definition": "| { tag: \"Lit\""
      }
    },
    {
      "name": "ExprFOptics",
      "type": "type",
      "file": "src/types/optics-free.ts",
      "line": 223,
      "definition": "| { _tag: 'Const'",
      "shape": {
        "type": "primitive",
        "definition": "| { _tag: 'Const'"
      }
    },
    {
      "name": "FingerTree",
      "type": "type",
      "file": "src/types/fingertree.ts",
      "line": 77,
      "definition": "| { tag: \"Empty\" }\n  | { tag: \"Single\"",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "tag",
            "optional": false,
            "type": "\"Empty\""
          }
        ]
      }
    },
    {
      "name": "Finite",
      "type": "interface",
      "file": "src/types/strong-monad.ts",
      "line": 169,
      "properties": [
        {
          "name": "elems",
          "optional": false,
          "type": "A[]"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "elems",
            "optional": false,
            "type": "A[]"
          }
        ]
      }
    },
    {
      "name": "FiniteAbGroup",
      "type": "type",
      "file": "src/structures/ab/AbGroup.ts",
      "line": 4,
      "definition": "FiniteGroup<A>",
      "shape": {
        "type": "primitive",
        "definition": "FiniteGroup<A>"
      }
    },
    {
      "name": "FiniteGroup",
      "type": "interface",
      "file": "src/structures/group/Group.ts",
      "line": 2,
      "properties": [
        {
          "name": "elems",
          "optional": false,
          "type": "T[]"
        },
        {
          "name": "eq",
          "optional": false,
          "type": "(a: T, b: T) => boolean"
        },
        {
          "name": "eq",
          "optional": false,
          "type": "method",
          "signature": "(a: T, b: T)",
          "returnType": "boolean"
        },
        {
          "name": "op",
          "optional": false,
          "type": "(a: T, b: T) => T"
        },
        {
          "name": "op",
          "optional": false,
          "type": "method",
          "signature": "(a: T, b: T)",
          "returnType": "T"
        },
        {
          "name": "id",
          "optional": false,
          "type": "T"
        },
        {
          "name": "inv",
          "optional": false,
          "type": "(a: T) => T"
        },
        {
          "name": "inv",
          "optional": false,
          "type": "method",
          "signature": "(a: T)",
          "returnType": "T"
        },
        {
          "name": "label",
          "optional": true,
          "type": "string"
        }
      ],
      "shape": {
        "propertyCount": 9,
        "properties": [
          {
            "name": "elems",
            "optional": false,
            "type": "T[]"
          },
          {
            "name": "eq",
            "optional": false,
            "type": "(a: T, b: T) => boolean"
          },
          {
            "name": "eq",
            "optional": false,
            "type": "method"
          },
          {
            "name": "id",
            "optional": false,
            "type": "T"
          },
          {
            "name": "inv",
            "optional": false,
            "type": "(a: T) => T"
          },
          {
            "name": "inv",
            "optional": false,
            "type": "method"
          },
          {
            "name": "label",
            "optional": true,
            "type": "string"
          },
          {
            "name": "op",
            "optional": false,
            "type": "(a: T, b: T) => T"
          },
          {
            "name": "op",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "FiniteMonoid",
      "type": "type",
      "file": "src/algebra/semiringlike/Monoid.ts",
      "line": 3,
      "definition": "FiniteSemigroup<A> & {\n  e: A",
      "shape": {
        "type": "primitive",
        "definition": "FiniteSemigroup<A> & {\n  e: A"
      }
    },
    {
      "name": "FiniteProf",
      "type": "interface",
      "file": "src/types/category-to-nerve-sset.ts",
      "line": 1153,
      "properties": [
        {
          "name": "elems",
          "optional": false,
          "type": "(a: A_O, b: B_O) => ReadonlyArray<T>"
        },
        {
          "name": "elems",
          "optional": false,
          "type": "method",
          "signature": "(a: A_O, b: B_O)",
          "returnType": "ReadonlyArray<T>"
        },
        {
          "name": "lmap",
          "optional": false,
          "type": "(u: A_M, b: B_O, t: T) => T"
        },
        {
          "name": "lmap",
          "optional": false,
          "type": "method",
          "signature": "(u: A_M, b: B_O, t: T)",
          "returnType": "T"
        },
        {
          "name": "rmap",
          "optional": false,
          "type": "(a: A_O, v: B_M, t: T) => T"
        },
        {
          "name": "rmap",
          "optional": false,
          "type": "method",
          "signature": "(a: A_O, v: B_M, t: T)",
          "returnType": "T"
        }
      ],
      "shape": {
        "propertyCount": 6,
        "properties": [
          {
            "name": "elems",
            "optional": false,
            "type": "(a: A_O, b: B_O) => ReadonlyT[]"
          },
          {
            "name": "elems",
            "optional": false,
            "type": "method"
          },
          {
            "name": "lmap",
            "optional": false,
            "type": "(u: A_M, b: B_O, t: T) => T"
          },
          {
            "name": "lmap",
            "optional": false,
            "type": "method"
          },
          {
            "name": "rmap",
            "optional": false,
            "type": "(a: A_O, v: B_M, t: T) => T"
          },
          {
            "name": "rmap",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "FiniteRing",
      "type": "type",
      "file": "src/structures/ring/Ring.ts",
      "line": 5,
      "definition": "{\n  elems: A[]",
      "shape": {
        "type": "primitive",
        "definition": "{\n  elems: A[]"
      }
    },
    {
      "name": "FiniteSemigroup",
      "type": "type",
      "file": "src/algebra/semiringlike/Semigroup.ts",
      "line": 1,
      "definition": "{\n  elems: A[]",
      "shape": {
        "type": "primitive",
        "definition": "{\n  elems: A[]"
      }
    },
    {
      "name": "FiniteSet",
      "type": "type",
      "file": "src/set/Set.ts",
      "line": 6,
      "definition": "{\n  elems: A[]",
      "shape": {
        "type": "primitive",
        "definition": "{\n  elems: A[]"
      }
    },
    {
      "name": "FiniteSubset",
      "type": "type",
      "file": "src/types/ultrafilter.ts",
      "line": 11,
      "definition": "Set<A>",
      "shape": {
        "type": "primitive",
        "definition": "Set<A>"
      }
    },
    {
      "name": "FinVect",
      "type": "type",
      "file": "src/types/finvect.ts",
      "line": 49,
      "definition": "{ \n  dim: number",
      "shape": {
        "type": "primitive",
        "definition": "{ \n  dim: number"
      }
    },
    {
      "name": "Fix",
      "type": "type",
      "file": "src/types/advanced.ts",
      "line": 279,
      "definition": "{ unfix: HKT<F, Fix<F>> }",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "unfix",
            "optional": false,
            "type": "HKT<T>>"
          }
        ]
      }
    },
    {
      "name": "Fn",
      "type": "type",
      "file": "src/types/hkt.ts",
      "line": 32,
      "definition": "(a: A) => B",
      "shape": {
        "type": "function",
        "signature": "(a: A) => B"
      }
    },
    {
      "name": "FnM",
      "type": "type",
      "file": "src/types/category-to-nerve-sset.ts",
      "line": 768,
      "definition": "{\n  src: SetObj<any>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  src: SetObj<any>"
      }
    },
    {
      "name": "Foldable",
      "type": "interface",
      "file": "src/types/foldable.ts",
      "line": 10,
      "properties": [
        {
          "name": "reduce",
          "optional": false,
          "type": "<A, B>(fa: HKT<F, A>, b: B, f: (b: B, a: A) => B) => B"
        },
        {
          "name": "reduceRight",
          "optional": false,
          "type": "<A, B>(fa: HKT<F, A>, b: B, f: (a: A, b: B) => B) => B"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "reduce",
            "optional": false,
            "type": "<A, B>(fa: HKT<T>, b: B, f: (b: B, a: A) => B) => B"
          },
          {
            "name": "reduceRight",
            "optional": false,
            "type": "<A, B>(fa: HKT<T>, b: B, f: (a: A, b: B) => B) => B"
          }
        ]
      }
    },
    {
      "name": "Forget",
      "type": "type",
      "file": "src/types/catkit-prisms.ts",
      "line": 44,
      "definition": "(a:A)=>R",
      "shape": {
        "type": "function",
        "signature": "(a:A)=>R"
      }
    },
    {
      "name": "ForgetFree",
      "type": "type",
      "file": "src/types/optics-free.ts",
      "line": 60,
      "definition": "((a: A) => R) & { _phantom?: B }",
      "shape": {
        "type": "function",
        "signature": "((a: A) => R) & { _phantom?: B }"
      }
    },
    {
      "name": "ForgetProfunctor",
      "type": "type",
      "file": "src/types/advanced.ts",
      "line": 105,
      "definition": "HKT2Prof<PFG, A, B> & ((a: A) => R)\n\n// Simplified versions for the HKT system\nconst forgetProfunctor = (): Profunctor2<PFG> => ({\n  dimap: (pab: unknown, l: unknown, _r: unknown) => {\n    const pabFn = unsafeCoerce<unknown, (x: unknown) => unknown>(pab)",
      "shape": {
        "type": "function",
        "signature": "HKT2Prof<PFG, A, B> & ((a: A) => R)\n\n// Simplified versions for the HKT system\nconst forgetProfunctor = (): Profunctor2<PFG> => ({\n  dimap: (pab: unknown, l: unknown, _r: unknown) => {\n    const pabFn = unsafeCoerce<unknown, (x: unknown) => unknown>(pab)"
      }
    },
    {
      "name": "FormF",
      "type": "type",
      "file": "src/types/freeapp-coyo.ts",
      "line": 127,
      "definition": "| { tag: \"Field\"",
      "shape": {
        "type": "primitive",
        "definition": "| { tag: \"Field\""
      }
    },
    {
      "name": "FoundTag",
      "type": "interface",
      "file": "src/types/math-trace-types.ts",
      "line": 25,
      "properties": [
        {
          "name": "file",
          "optional": false,
          "type": "string"
        },
        {
          "name": "line",
          "optional": false,
          "type": "number"
        },
        {
          "name": "tag",
          "optional": false,
          "type": "\"@math\" | \"@law\""
        },
        {
          "name": "id",
          "optional": false,
          "type": "string"
        },
        {
          "name": "context",
          "optional": true,
          "type": "string; // Surrounding code context"
        }
      ],
      "shape": {
        "propertyCount": 5,
        "properties": [
          {
            "name": "context",
            "optional": true,
            "type": "string; // Surrounding code context"
          },
          {
            "name": "file",
            "optional": false,
            "type": "string"
          },
          {
            "name": "id",
            "optional": false,
            "type": "string"
          },
          {
            "name": "line",
            "optional": false,
            "type": "number"
          },
          {
            "name": "tag",
            "optional": false,
            "type": "\"@math\" | \"@law\""
          }
        ]
      }
    },
    {
      "name": "Free",
      "type": "type",
      "file": "src/types/optics-rewrite.ts",
      "line": 56,
      "definition": "| { _tag: \"Pure\"",
      "shape": {
        "type": "primitive",
        "definition": "| { _tag: \"Pure\""
      }
    },
    {
      "name": "FreeAlgebra",
      "type": "type",
      "file": "src/universal/rewrite/SetMonad.ts",
      "line": 19,
      "definition": "Term[]",
      "shape": {
        "type": "primitive",
        "definition": "Term[]"
      }
    },
    {
      "name": "FreeAp",
      "type": "type",
      "file": "src/types/freeapp-coyo.ts",
      "line": 19,
      "definition": "| { tag: \"Pure\"",
      "shape": {
        "type": "primitive",
        "definition": "| { tag: \"Pure\""
      }
    },
    {
      "name": "FreeCoalgebra",
      "type": "interface",
      "file": "src/types/advanced.ts",
      "line": 231,
      "properties": [
        {
          "name": "coalg",
          "optional": false,
          "type": "<A>(a: A) => HKT<F, A>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "coalg",
            "optional": false,
            "type": "<A>(a: A) => HKT<T>"
          }
        ]
      }
    },
    {
      "name": "FreeLegacy",
      "type": "type",
      "file": "src/types/advanced.ts",
      "line": 276,
      "definition": "Pure<A> | Suspend<HKT<F, FreeLegacy<F, A>>>",
      "shape": {
        "type": "primitive",
        "definition": "Pure<A> | Suspend<HKT<F, FreeLegacy<F, A>>>"
      }
    },
    {
      "name": "FreeOptics",
      "type": "type",
      "file": "src/types/optics-free.ts",
      "line": 200,
      "definition": "| { _tag: 'Pure'",
      "shape": {
        "type": "primitive",
        "definition": "| { _tag: 'Pure'"
      }
    },
    {
      "name": "Fun",
      "type": "type",
      "file": "src/types/rel-equipment.ts",
      "line": 179,
      "definition": "(a:A)=>B",
      "shape": {
        "type": "function",
        "signature": "(a:A)=>B"
      }
    },
    {
      "name": "FunctionSpace",
      "type": "type",
      "file": "src/types/ran-set.ts",
      "line": 21,
      "definition": "Map<string, Cod> & {\n  readonly __dom: ReadonlyArray<Dom>",
      "shape": {
        "type": "primitive",
        "definition": "Map<string, Cod> & {\n  readonly __dom: ReadonlyArray<Dom>"
      }
    },
    {
      "name": "Functor",
      "type": "interface",
      "file": "src/types/functors.ts",
      "line": 9,
      "properties": [
        {
          "name": "map",
          "optional": false,
          "type": "<A, B>(fa: HKT<F, A>, f: (a: A) => B) => HKT<F, B>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "map",
            "optional": false,
            "type": "<A, B>(fa: HKT<T>, f: (a: A) => B) => HKT<T>"
          }
        ]
      }
    },
    {
      "name": "FunctorAlgebra",
      "type": "interface",
      "file": "src/types/adt-functor.ts",
      "line": 15,
      "properties": [
        {
          "name": "carrier",
          "optional": false,
          "type": "A"
        },
        {
          "name": "structure",
          "optional": false,
          "type": "(fa: F) => A"
        },
        {
          "name": "structure",
          "optional": false,
          "type": "method",
          "signature": "(fa: F)",
          "returnType": "A"
        }
      ],
      "shape": {
        "propertyCount": 3,
        "properties": [
          {
            "name": "carrier",
            "optional": false,
            "type": "A"
          },
          {
            "name": "structure",
            "optional": false,
            "type": "(fa: F) => A"
          },
          {
            "name": "structure",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "FunctorCoalgebra",
      "type": "interface",
      "file": "src/types/adt-functor.ts",
      "line": 24,
      "properties": [
        {
          "name": "carrier",
          "optional": false,
          "type": "A"
        },
        {
          "name": "structure",
          "optional": false,
          "type": "(a: A) => F"
        },
        {
          "name": "structure",
          "optional": false,
          "type": "method",
          "signature": "(a: A)",
          "returnType": "F"
        }
      ],
      "shape": {
        "propertyCount": 3,
        "properties": [
          {
            "name": "carrier",
            "optional": false,
            "type": "A"
          },
          {
            "name": "structure",
            "optional": false,
            "type": "(a: A) => F"
          },
          {
            "name": "structure",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "FunctorF",
      "type": "interface",
      "file": "src/types/adt-functor.ts",
      "line": 3,
      "properties": [
        {
          "name": "map",
          "optional": false,
          "type": "(f: (a: A) => B) => FunctorF<B, any>; // nominal tag"
        },
        {
          "name": "map",
          "optional": false,
          "type": "method",
          "signature": "(f: (a: A)",
          "returnType": "B) => FunctorF<B, any>; // nominal tag"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "map",
            "optional": false,
            "type": "(f: (a: A) => B) => FunctorF<T>; // nominal tag"
          },
          {
            "name": "map",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "FunctorFree",
      "type": "interface",
      "file": "src/types/optics-free.ts",
      "line": 144,
      "properties": [
        {
          "name": "map",
          "optional": false,
          "type": "<A, B>(fa: KindFree<F, A>, f: (a: A) => B) => KindFree<F, B>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "map",
            "optional": false,
            "type": "<A, B>(fa: KindFree<T>, f: (a: A) => B) => KindFree<T>"
          }
        ]
      }
    },
    {
      "name": "FunEqWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 20,
      "definition": "| { equal: true",
      "shape": {
        "type": "primitive",
        "definition": "| { equal: true"
      }
    },
    {
      "name": "GAlgebra",
      "type": "type",
      "file": "src/gadt/Initial.ts",
      "line": 4,
      "definition": "(fa: F) => A",
      "shape": {
        "type": "function",
        "signature": "(fa: F) => A"
      }
    },
    {
      "name": "GaloisAdjunctionWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 163,
      "definition": "{\n  f: (a: A) => B",
      "shape": {
        "type": "function",
        "signature": "{\n  f: (a: A) => B"
      }
    },
    {
      "name": "GaloisConnection",
      "type": "interface",
      "file": "src/types/catkit-posets.ts",
      "line": 134,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "GaloisConnectionWitness",
      "type": "type",
      "file": "src/types/rel-lawcheck-witnessed.ts",
      "line": 30,
      "definition": "{\n  existsPreimageAdjunction: LawCheck<{ f: any",
      "shape": {
        "type": "primitive",
        "definition": "{\n  existsPreimageAdjunction: LawCheck<{ f: any"
      }
    },
    {
      "name": "GB",
      "type": "type",
      "file": "src/gadt/basic/BFin.Lan.ts",
      "line": 19,
      "definition": "Either<Unit, BFin<b>>",
      "shape": {
        "type": "primitive",
        "definition": "Either<Unit, BFin<b>>"
      }
    },
    {
      "name": "GBuilder",
      "type": "type",
      "file": "src/gadt/Initial.ts",
      "line": 15,
      "definition": "<A>(alg: GAlgebra<F,A>) => A",
      "shape": {
        "type": "function",
        "signature": "<A>(alg: GAlgebra<F,A>) => A"
      }
    },
    {
      "name": "GCoalgebra",
      "type": "type",
      "file": "src/gadt/Initial.ts",
      "line": 5,
      "definition": "(a: A) => F",
      "shape": {
        "type": "function",
        "signature": "(a: A) => F"
      }
    },
    {
      "name": "GroupHom",
      "type": "interface",
      "file": "src/structures/group/Hom.ts",
      "line": 4,
      "properties": [
        {
          "name": "source",
          "optional": false,
          "type": "FiniteGroup<A>"
        },
        {
          "name": "target",
          "optional": false,
          "type": "FiniteGroup<B>"
        },
        {
          "name": "f",
          "optional": false,
          "type": "(a: A) => B"
        },
        {
          "name": "f",
          "optional": false,
          "type": "method",
          "signature": "(a: A)",
          "returnType": "B"
        },
        {
          "name": "name",
          "optional": true,
          "type": "string"
        }
      ],
      "shape": {
        "propertyCount": 5,
        "properties": [
          {
            "name": "f",
            "optional": false,
            "type": "(a: A) => B"
          },
          {
            "name": "f",
            "optional": false,
            "type": "method"
          },
          {
            "name": "name",
            "optional": true,
            "type": "string"
          },
          {
            "name": "source",
            "optional": false,
            "type": "FiniteGroup<T>"
          },
          {
            "name": "target",
            "optional": false,
            "type": "FiniteGroup<T>"
          }
        ]
      }
    },
    {
      "name": "GroupHomWitnesses",
      "type": "interface",
      "file": "src/algebra/group/analyzeHom.ts",
      "line": 5,
      "properties": [
        {
          "name": "preservesOp",
          "optional": false,
          "type": "boolean"
        },
        {
          "name": "preservesId",
          "optional": false,
          "type": "boolean"
        },
        {
          "name": "preservesInv",
          "optional": false,
          "type": "boolean"
        },
        {
          "name": "imageSubgroup",
          "optional": true,
          "type": "Subgroup<B>"
        },
        {
          "name": "kernelSubgroup",
          "optional": true,
          "type": "Subgroup<A>"
        }
      ],
      "shape": {
        "propertyCount": 5,
        "properties": [
          {
            "name": "imageSubgroup",
            "optional": true,
            "type": "Subgroup<T>"
          },
          {
            "name": "kernelSubgroup",
            "optional": true,
            "type": "Subgroup<T>"
          },
          {
            "name": "preservesId",
            "optional": false,
            "type": "boolean"
          },
          {
            "name": "preservesInv",
            "optional": false,
            "type": "boolean"
          },
          {
            "name": "preservesOp",
            "optional": false,
            "type": "boolean"
          }
        ]
      }
    },
    {
      "name": "GroupIso",
      "type": "type",
      "file": "src/structures/group/iso/GroupIso.ts",
      "line": 8,
      "definition": "{\n  forward: GroupHom<A, B>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  forward: GroupHom<A, B>"
      }
    },
    {
      "name": "GV",
      "type": "type",
      "file": "src/gadt/basic/Vec.Lan.ts",
      "line": 11,
      "definition": "Pair<A, Vec<b, A>>",
      "shape": {
        "type": "primitive",
        "definition": "Pair<A, Vec<b, A>>"
      }
    },
    {
      "name": "H1Presentation",
      "type": "type",
      "file": "src/types/catkit-homology.ts",
      "line": 493,
      "definition": "{\n  generators: string[]",
      "shape": {
        "type": "primitive",
        "definition": "{\n  generators: string[]"
      }
    },
    {
      "name": "HAlgebra",
      "type": "type",
      "file": "src/higher/HFix.ts",
      "line": 39,
      "definition": "(fr: FNode) => R",
      "shape": {
        "type": "function",
        "signature": "(fr: FNode) => R"
      }
    },
    {
      "name": "HasHom",
      "type": "interface",
      "file": "src/types/catkit-kan.ts",
      "line": 16,
      "properties": [
        {
          "name": "hom",
          "optional": false,
          "type": "(x: O, y: O) => ReadonlyArray<M>"
        },
        {
          "name": "hom",
          "optional": false,
          "type": "method",
          "signature": "(x: O, y: O)",
          "returnType": "ReadonlyArray<M>"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "hom",
            "optional": false,
            "type": "(x: O, y: O) => ReadonlyM[]"
          },
          {
            "name": "hom",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "HeytingAlgebra",
      "type": "interface",
      "file": "src/types/algebraic.ts",
      "line": 58,
      "properties": [
        {
          "name": "implies",
          "optional": false,
          "type": "(x: A, y: A) => A"
        },
        {
          "name": "implies",
          "optional": false,
          "type": "method",
          "signature": "(x: A, y: A)",
          "returnType": "A"
        },
        {
          "name": "meet",
          "optional": false,
          "type": "(x: A, y: A) => A"
        },
        {
          "name": "meet",
          "optional": false,
          "type": "method",
          "signature": "(x: A, y: A)",
          "returnType": "A"
        },
        {
          "name": "join",
          "optional": false,
          "type": "(x: A, y: A) => A"
        },
        {
          "name": "join",
          "optional": false,
          "type": "method",
          "signature": "(x: A, y: A)",
          "returnType": "A"
        },
        {
          "name": "top",
          "optional": false,
          "type": "A"
        },
        {
          "name": "bottom",
          "optional": false,
          "type": "A"
        },
        {
          "name": "not",
          "optional": false,
          "type": "(a: A) => A"
        },
        {
          "name": "not",
          "optional": false,
          "type": "method",
          "signature": "(a: A)",
          "returnType": "A"
        }
      ],
      "shape": {
        "propertyCount": 10,
        "properties": [
          {
            "name": "bottom",
            "optional": false,
            "type": "A"
          },
          {
            "name": "implies",
            "optional": false,
            "type": "(x: A, y: A) => A"
          },
          {
            "name": "implies",
            "optional": false,
            "type": "method"
          },
          {
            "name": "join",
            "optional": false,
            "type": "(x: A, y: A) => A"
          },
          {
            "name": "join",
            "optional": false,
            "type": "method"
          },
          {
            "name": "meet",
            "optional": false,
            "type": "(x: A, y: A) => A"
          },
          {
            "name": "meet",
            "optional": false,
            "type": "method"
          },
          {
            "name": "not",
            "optional": false,
            "type": "(a: A) => A"
          },
          {
            "name": "not",
            "optional": false,
            "type": "method"
          },
          {
            "name": "top",
            "optional": false,
            "type": "A"
          }
        ]
      }
    },
    {
      "name": "HFix",
      "type": "type",
      "file": "src/higher/HFix.ts",
      "line": 34,
      "definition": "{ readonly _tag: \"HFix\"",
      "shape": {
        "type": "primitive",
        "definition": "{ readonly _tag: \"HFix\""
      }
    },
    {
      "name": "HFunctor",
      "type": "interface",
      "file": "src/gadt/HFun.ts",
      "line": 5,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "HKT",
      "type": "type",
      "file": "src/types/hkt.ts",
      "line": 18,
      "definition": "URI extends URIS ? Kind<URI, A> : unknown",
      "shape": {
        "type": "primitive",
        "definition": "URI extends URIS ? Kind<URI, A> : unknown"
      }
    },
    {
      "name": "HKT2",
      "type": "type",
      "file": "src/types/hkt.ts",
      "line": 19,
      "definition": "URI extends URIS2 ? Kind2<URI, E, A> : unknown",
      "shape": {
        "type": "primitive",
        "definition": "URI extends URIS2 ? Kind2<URI, E, A> : unknown"
      }
    },
    {
      "name": "HKT2Prof",
      "type": "type",
      "file": "src/types/hkt.ts",
      "line": 26,
      "definition": "URI extends URISProf ? KindProf<URI, A, B> : unknown",
      "shape": {
        "type": "primitive",
        "definition": "URI extends URISProf ? KindProf<URI, A, B> : unknown"
      }
    },
    {
      "name": "HKT3",
      "type": "type",
      "file": "src/types/hkt.ts",
      "line": 20,
      "definition": "URI extends URIS3 ? Kind3<URI, R, E, A> : unknown",
      "shape": {
        "type": "primitive",
        "definition": "URI extends URIS3 ? Kind3<URI, R, E, A> : unknown"
      }
    },
    {
      "name": "HoareWitness",
      "type": "type",
      "file": "src/types/allegory-witness.ts",
      "line": 72,
      "definition": "| { ok: true",
      "shape": {
        "type": "primitive",
        "definition": "| { ok: true"
      }
    },
    {
      "name": "HomologyBuildOptions",
      "type": "type",
      "file": "src/types/catkit-homology.ts",
      "line": 18,
      "definition": "{ maxPathLen?: number }",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "maxPathLen",
            "optional": true,
            "type": "number"
          }
        ]
      }
    },
    {
      "name": "HomologyEdge",
      "type": "type",
      "file": "src/types/catkit-homology.ts",
      "line": 14,
      "definition": "{ src: HomologyObj",
      "shape": {
        "type": "primitive",
        "definition": "{ src: HomologyObj"
      }
    },
    {
      "name": "HomologyObj",
      "type": "type",
      "file": "src/types/catkit-homology.ts",
      "line": 13,
      "definition": "string",
      "shape": {
        "type": "primitive",
        "definition": "string"
      }
    },
    {
      "name": "HomologyPath",
      "type": "type",
      "file": "src/types/catkit-homology.ts",
      "line": 15,
      "definition": "{ src: HomologyObj",
      "shape": {
        "type": "primitive",
        "definition": "{ src: HomologyObj"
      }
    },
    {
      "name": "HomologyQuiver",
      "type": "type",
      "file": "src/types/catkit-homology.ts",
      "line": 16,
      "definition": "{ objects: HomologyObj[]",
      "shape": {
        "type": "primitive",
        "definition": "{ objects: HomologyObj[]"
      }
    },
    {
      "name": "HomologyTwoSimplex",
      "type": "type",
      "file": "src/types/catkit-homology.ts",
      "line": 17,
      "definition": "{ f: HomologyPath",
      "shape": {
        "type": "primitive",
        "definition": "{ f: HomologyPath"
      }
    },
    {
      "name": "Horn2Inner",
      "type": "type",
      "file": "src/types/sset-quasicat.ts",
      "line": 160,
      "definition": "{ tag:\"inner\"",
      "shape": {
        "type": "primitive",
        "definition": "{ tag:\"inner\""
      }
    },
    {
      "name": "Horn2InnerCheck",
      "type": "type",
      "file": "src/types/sset-quasicat.ts",
      "line": 173,
      "definition": "{ horn: Horn2Inner",
      "shape": {
        "type": "primitive",
        "definition": "{ horn: Horn2Inner"
      }
    },
    {
      "name": "Horn2Outer",
      "type": "type",
      "file": "src/types/sset-quasicat.ts",
      "line": 195,
      "definition": "| { tag:\"outer0\"",
      "shape": {
        "type": "primitive",
        "definition": "| { tag:\"outer0\""
      }
    },
    {
      "name": "Horn2OuterCheck",
      "type": "type",
      "file": "src/types/sset-quasicat.ts",
      "line": 216,
      "definition": "{ horn: Horn2Outer",
      "shape": {
        "type": "primitive",
        "definition": "{ horn: Horn2Outer"
      }
    },
    {
      "name": "Horn3",
      "type": "type",
      "file": "src/types/sset-quasicat.ts",
      "line": 248,
      "definition": "{ missing: 1|2",
      "shape": {
        "type": "primitive",
        "definition": "{ missing: 1|2"
      }
    },
    {
      "name": "Horn3Check",
      "type": "type",
      "file": "src/types/sset-quasicat.ts",
      "line": 282,
      "definition": "{ horn: Horn3",
      "shape": {
        "type": "primitive",
        "definition": "{ horn: Horn3"
      }
    },
    {
      "name": "HornSpec",
      "type": "type",
      "file": "src/types/sset-quasicat.ts",
      "line": 421,
      "definition": "| { kind:\"Lambda2_1\"",
      "shape": {
        "type": "primitive",
        "definition": "| { kind:\"Lambda2_1\""
      }
    },
    {
      "name": "Id",
      "type": "type",
      "file": "src/types/catkit-traversal.ts",
      "line": 18,
      "definition": "{ tag:\"Id\", value:A }",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "tag",
            "optional": false,
            "type": "\"Id\", value:A"
          }
        ]
      }
    },
    {
      "name": "Ideal",
      "type": "type",
      "file": "src/structures/ring/Ideal.ts",
      "line": 4,
      "definition": "{\n  ring: FiniteRing<A>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  ring: FiniteRing<A>"
      }
    },
    {
      "name": "InclusionWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 10,
      "definition": "| { holds: true",
      "shape": {
        "type": "primitive",
        "definition": "| { holds: true"
      }
    },
    {
      "name": "InitialAlgebra",
      "type": "interface",
      "file": "src/types/adt-functor.ts",
      "line": 42,
      "properties": [
        {
          "name": "carrier",
          "optional": false,
          "type": "any; // μF - the fixpoint"
        },
        {
          "name": "structure",
          "optional": false,
          "type": "(f: F) => any; // F(μF) → μF"
        },
        {
          "name": "structure",
          "optional": false,
          "type": "method",
          "signature": "(f: F)",
          "returnType": "any; // F(μF) → μF"
        },
        {
          "name": "cata",
          "optional": false,
          "type": "<A>(alg: FunctorAlgebra<F, A>) => (mu: any) => A; // unique homomorphism"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "carrier",
            "optional": false,
            "type": "any; // μF - the fixpoint"
          },
          {
            "name": "cata",
            "optional": false,
            "type": "<A>(alg: FunctorAlgebra<T>) => (mu: any) => A; // unique homomorphism"
          },
          {
            "name": "structure",
            "optional": false,
            "type": "(f: F) => any; // F(μF) → μF"
          },
          {
            "name": "structure",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "Inl",
      "type": "type",
      "file": "src/types/adt-sum-prod.ts",
      "line": 3,
      "definition": "{ _t: \"inl\"",
      "shape": {
        "type": "primitive",
        "definition": "{ _t: \"inl\""
      }
    },
    {
      "name": "InnerHorn2",
      "type": "type",
      "file": "src/types/category-to-nerve-sset.ts",
      "line": 384,
      "definition": "{\n  /** d0 face: the \"right\" edge x1→x2 */\n  readonly d0: NSimplex<O, M>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  /** d0 face: the \"right\" edge x1→x2 */\n  readonly d0: NSimplex<O, M>"
      }
    },
    {
      "name": "InnerHornN",
      "type": "type",
      "file": "src/types/category-to-nerve-sset.ts",
      "line": 931,
      "definition": "{\n  n: number",
      "shape": {
        "type": "primitive",
        "definition": "{\n  n: number"
      }
    },
    {
      "name": "Inr",
      "type": "type",
      "file": "src/types/adt-sum-prod.ts",
      "line": 4,
      "definition": "{ _t: \"inr\"",
      "shape": {
        "type": "primitive",
        "definition": "{ _t: \"inr\""
      }
    },
    {
      "name": "Int",
      "type": "type",
      "file": "src/types/snf-witness.ts",
      "line": 7,
      "definition": "number",
      "shape": {
        "type": "primitive",
        "definition": "number"
      }
    },
    {
      "name": "Invariant",
      "type": "interface",
      "file": "src/types/functors.ts",
      "line": 19,
      "properties": [
        {
          "name": "imap",
          "optional": false,
          "type": "<A, B>(fa: HKT<F, A>, to: (a: A) => B, from: (b: B) => A) => HKT<F, B>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "imap",
            "optional": false,
            "type": "<A, B>(fa: HKT<T>, to: (a: A) => B, from: (b: B) => A) => HKT<T>"
          }
        ]
      }
    },
    {
      "name": "IRel",
      "type": "interface",
      "file": "src/types/rel-common.ts",
      "line": 9,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "Iso",
      "type": "interface",
      "file": "src/types/catkit-equivalence.ts",
      "line": 46,
      "properties": [
        {
          "name": "C",
          "optional": false,
          "type": "SmallCategory<O,M>"
        },
        {
          "name": "a",
          "optional": false,
          "type": "O; b: O"
        },
        {
          "name": "f",
          "optional": false,
          "type": "M; g: M; // f:a→b, g:b→a"
        }
      ],
      "shape": {
        "propertyCount": 3,
        "properties": [
          {
            "name": "a",
            "optional": false,
            "type": "O; b: O"
          },
          {
            "name": "C",
            "optional": false,
            "type": "SmallCategory<T>"
          },
          {
            "name": "f",
            "optional": false,
            "type": "M; g: M; // f:a→b, g:b→a"
          }
        ]
      }
    },
    {
      "name": "IsoClass",
      "type": "interface",
      "file": "src/algebra/group/IsoClass.ts",
      "line": 9,
      "properties": [
        {
          "name": "toCanonical",
          "optional": true,
          "type": "GroupIso<G, any>"
        },
        {
          "name": "fromCanonical",
          "optional": true,
          "type": "GroupIso<any, G>"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "fromCanonical",
            "optional": true,
            "type": "GroupIso<T>"
          },
          {
            "name": "toCanonical",
            "optional": true,
            "type": "GroupIso<T>"
          }
        ]
      }
    },
    {
      "name": "JoinSemilattice",
      "type": "interface",
      "file": "src/types/algebraic.ts",
      "line": 47,
      "properties": [
        {
          "name": "join",
          "optional": false,
          "type": "(x: A, y: A) => A"
        },
        {
          "name": "join",
          "optional": false,
          "type": "method",
          "signature": "(x: A, y: A)",
          "returnType": "A"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "join",
            "optional": false,
            "type": "(x: A, y: A) => A"
          },
          {
            "name": "join",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "KanExtensionProblem",
      "type": "interface",
      "file": "src/types/catkit-comma-kan-bridge.ts",
      "line": 21,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "Kernel",
      "type": "type",
      "file": "src/prob/Kleisli.ts",
      "line": 4,
      "definition": "(a: A) => Dist<B>",
      "shape": {
        "type": "function",
        "signature": "(a: A) => Dist<B>"
      }
    },
    {
      "name": "Kind",
      "type": "type",
      "file": "src/types/hkt.ts",
      "line": 6,
      "definition": "URItoKind<A>[U]",
      "shape": {
        "type": "primitive",
        "definition": "URItoKind<A>[U]"
      }
    },
    {
      "name": "Kind2",
      "type": "type",
      "file": "src/types/hkt.ts",
      "line": 11,
      "definition": "URItoKind2<E, A>[U]",
      "shape": {
        "type": "primitive",
        "definition": "URItoKind2<E, A>[U]"
      }
    },
    {
      "name": "Kind3",
      "type": "type",
      "file": "src/types/hkt.ts",
      "line": 15,
      "definition": "URItoKind3<R, E, A>[U]",
      "shape": {
        "type": "primitive",
        "definition": "URItoKind3<R, E, A>[U]"
      }
    },
    {
      "name": "KindProf",
      "type": "type",
      "file": "src/types/hkt.ts",
      "line": 25,
      "definition": "URItoKindProf<A, B>[U]",
      "shape": {
        "type": "primitive",
        "definition": "URItoKindProf<A, B>[U]"
      }
    },
    {
      "name": "KleisliHom",
      "type": "type",
      "file": "src/universal/monad/Diagram.ts",
      "line": 6,
      "definition": "(a:A)=>Term",
      "shape": {
        "type": "function",
        "signature": "(a:A)=>Term"
      }
    },
    {
      "name": "Lan",
      "type": "type",
      "file": "src/category/Lan.ts",
      "line": 14,
      "definition": "<b>(eq: Eq<h, c>) => g",
      "shape": {
        "type": "function",
        "signature": "<b>(eq: Eq<h, c>) => g"
      }
    },
    {
      "name": "Lan1",
      "type": "type",
      "file": "src/category/Lan.ts",
      "line": 17,
      "definition": "<B>(e: Eq<H, C>) => G",
      "shape": {
        "type": "function",
        "signature": "<B>(e: Eq<H, C>) => G"
      }
    },
    {
      "name": "LanIdId",
      "type": "type",
      "file": "src/category/examples/LanGadtBridge.ts",
      "line": 17,
      "definition": "Lan<Id<any>, Id<any>, c>",
      "shape": {
        "type": "primitive",
        "definition": "Lan<Id<any>, Id<any>, c>"
      }
    },
    {
      "name": "LanIdMaybe",
      "type": "type",
      "file": "src/category/examples/LanGadtBridge.ts",
      "line": 29,
      "definition": "Lan<Id<any>, Maybe<any>, c>",
      "shape": {
        "type": "primitive",
        "definition": "Lan<Id<any>, Maybe<any>, c>"
      }
    },
    {
      "name": "Lattice",
      "type": "type",
      "file": "src/order/Lattice.ts",
      "line": 4,
      "definition": "Poset<A> & {\n  join: (x:A,y:A)=>A",
      "shape": {
        "type": "function",
        "signature": "Poset<A> & {\n  join: (x:A,y:A)=>A"
      }
    },
    {
      "name": "Law",
      "type": "type",
      "file": "src/laws/Witness.ts",
      "line": 9,
      "definition": "{\n  name: string",
      "shape": {
        "type": "primitive",
        "definition": "{\n  name: string"
      }
    },
    {
      "name": "LawCheck",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 25,
      "definition": "| { ok: true",
      "shape": {
        "type": "primitive",
        "definition": "| { ok: true"
      }
    },
    {
      "name": "Lawful",
      "type": "type",
      "file": "src/laws/Witness.ts",
      "line": 18,
      "definition": "{\n  tag: string",
      "shape": {
        "type": "primitive",
        "definition": "{\n  tag: string"
      }
    },
    {
      "name": "Lawvere",
      "type": "type",
      "file": "src/universal/lawvere/Lawvere.ts",
      "line": 11,
      "definition": "{\n  sig: Signature",
      "shape": {
        "type": "primitive",
        "definition": "{\n  sig: Signature"
      }
    },
    {
      "name": "LeftComodule",
      "type": "interface",
      "file": "src/types/algebraic.ts",
      "line": 104,
      "properties": [
        {
          "name": "coact",
          "optional": false,
          "type": "<A>(ma: HKT<M, A>) => HKT<W, HKT<M, A>>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "coact",
            "optional": false,
            "type": "<A>(ma: HKT<T>) => HKT<T>>"
          }
        ]
      }
    },
    {
      "name": "LeftModule",
      "type": "interface",
      "file": "src/types/algebraic.ts",
      "line": 99,
      "properties": [
        {
          "name": "act",
          "optional": false,
          "type": "<A>(mta: HKT<M, HKT<T, A>>) => HKT<M, A>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "act",
            "optional": false,
            "type": "<A>(mta: HKT<T>>) => HKT<T>"
          }
        ]
      }
    },
    {
      "name": "Lens",
      "type": "type",
      "file": "src/types/optics-witness.ts",
      "line": 23,
      "definition": "{\n  get: (s:S)=>A",
      "shape": {
        "type": "function",
        "signature": "{\n  get: (s:S)=>A"
      }
    },
    {
      "name": "LensLawReport",
      "type": "type",
      "file": "src/types/catkit-optics.ts",
      "line": 99,
      "definition": "{ getSet: boolean",
      "shape": {
        "type": "primitive",
        "definition": "{ getSet: boolean"
      }
    },
    {
      "name": "LensWitness",
      "type": "type",
      "file": "src/types/optics-witness.ts",
      "line": 28,
      "definition": "{\n  getSet: { ok: true } | { ok: false",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "getSet",
            "optional": false,
            "type": "{ ok: true"
          }
        ]
      }
    },
    {
      "name": "LimitAtCState",
      "type": "type",
      "file": "src/types/pointwise-limit-util.ts",
      "line": 10,
      "definition": "{\n  /** families (x_j)_j satisfying all compatibility equations at c */\n  carrier: SetObj<any>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  /** families (x_j)_j satisfying all compatibility equations at c */\n  carrier: SetObj<any>"
      }
    },
    {
      "name": "LimitProblem",
      "type": "interface",
      "file": "src/types/catkit-comma-kan-bridge.ts",
      "line": 87,
      "properties": [
        {
          "name": "objects",
          "optional": false,
          "type": "ReadonlyArray<CObj>"
        },
        {
          "name": "morphisms",
          "optional": false,
          "type": "ReadonlyArray<CMor>"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "morphisms",
            "optional": false,
            "type": "ReadonlyCMor[]"
          },
          {
            "name": "objects",
            "optional": false,
            "type": "ReadonlyCObj[]"
          }
        ]
      }
    },
    {
      "name": "List",
      "type": "type",
      "file": "src/types/adt-list.ts",
      "line": 22,
      "definition": "Fix<ListF<any, A>>",
      "shape": {
        "type": "primitive",
        "definition": "Fix<ListF<any, A>>"
      }
    },
    {
      "name": "ListF",
      "type": "type",
      "file": "src/types/adt-list.ts",
      "line": 7,
      "definition": "Sum<{ _t: \"nil\" }, Pair<A, X>>",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "_t",
            "optional": false,
            "type": "\"nil\""
          }
        ]
      }
    },
    {
      "name": "M2",
      "type": "type",
      "file": "src/structures/ring/Ring.ts",
      "line": 71,
      "definition": "{ a:number,b:number,c:number,d:number }",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "a",
            "optional": false,
            "type": "number,b:number,c:number,d:number"
          }
        ]
      }
    },
    {
      "name": "Mat",
      "type": "type",
      "file": "src/types/snf-witness.ts",
      "line": 8,
      "definition": "Matrix",
      "shape": {
        "type": "primitive",
        "definition": "Matrix"
      }
    },
    {
      "name": "MathRecord",
      "type": "interface",
      "file": "src/types/math-trace-types.ts",
      "line": 14,
      "properties": [
        {
          "name": "id",
          "optional": false,
          "type": "string"
        },
        {
          "name": "title",
          "optional": false,
          "type": "string"
        },
        {
          "name": "statementLatex",
          "optional": true,
          "type": "string; // LaTeX excerpt for quick display"
        },
        {
          "name": "implicationsTS",
          "optional": true,
          "type": "string[]; // TypeScript APIs, types, operations unlocked"
        },
        {
          "name": "witnessLaws",
          "optional": true,
          "type": "string[]; // Concise law phrases for testing"
        },
        {
          "name": "futureUnlocks",
          "optional": true,
          "type": "string[]; // Ideas to remember later"
        },
        {
          "name": "sources",
          "optional": true,
          "type": "SourceRef[]"
        },
        {
          "name": "filePath",
          "optional": false,
          "type": "string; // Markdown file path"
        }
      ],
      "shape": {
        "propertyCount": 8,
        "properties": [
          {
            "name": "filePath",
            "optional": false,
            "type": "string; // Markdown file path"
          },
          {
            "name": "futureUnlocks",
            "optional": true,
            "type": "string[]; // Ideas to remember later"
          },
          {
            "name": "id",
            "optional": false,
            "type": "string"
          },
          {
            "name": "implicationsTS",
            "optional": true,
            "type": "string[]; // TypeScript APIs, types, operations unlocked"
          },
          {
            "name": "sources",
            "optional": true,
            "type": "SourceRef[]"
          },
          {
            "name": "statementLatex",
            "optional": true,
            "type": "string; // LaTeX excerpt for quick display"
          },
          {
            "name": "title",
            "optional": false,
            "type": "string"
          },
          {
            "name": "witnessLaws",
            "optional": true,
            "type": "string[]; // Concise law phrases for testing"
          }
        ]
      }
    },
    {
      "name": "Matrix",
      "type": "type",
      "file": "src/types/snf-surface-api.ts",
      "line": 10,
      "definition": "number[][]",
      "shape": {
        "type": "primitive",
        "definition": "number[][]"
      }
    },
    {
      "name": "Measured",
      "type": "type",
      "file": "src/types/measured-fingertree.ts",
      "line": 11,
      "definition": "{ measure: (x:T)=>M",
      "shape": {
        "type": "function",
        "signature": "{ measure: (x:T)=>M"
      }
    },
    {
      "name": "MeasuredFingerTree",
      "type": "type",
      "file": "src/types/measured-fingertree.ts",
      "line": 38,
      "definition": "| { t:\"Empty\", m:M }\n  | { t:\"Single\", x:T, m:M }\n  | { t:\"Deep\", m:M, prefix: Digit<T,M>, deeper: MeasuredFingerTree<Node<T,M>,M>, suffix: Digit<T,M> }",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "t",
            "optional": false,
            "type": "\"Empty\", m:M"
          }
        ]
      }
    },
    {
      "name": "MeetSemilattice",
      "type": "interface",
      "file": "src/types/algebraic.ts",
      "line": 43,
      "properties": [
        {
          "name": "meet",
          "optional": false,
          "type": "(x: A, y: A) => A"
        },
        {
          "name": "meet",
          "optional": false,
          "type": "method",
          "signature": "(x: A, y: A)",
          "returnType": "A"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "meet",
            "optional": false,
            "type": "(x: A, y: A) => A"
          },
          {
            "name": "meet",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "MigrationStep",
      "type": "interface",
      "file": "src/types/quiver-pushout.ts",
      "line": 382,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "ModLike",
      "type": "type",
      "file": "src/types/optics-rewrite.ts",
      "line": 150,
      "definition": "{ modify: (s:S, f:(a:A)=>A)=>S }",
      "shape": {
        "type": "function",
        "signature": "{ modify: (s:S, f:(a:A)=>A)=>S }"
      }
    },
    {
      "name": "MonadAssociativityWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 101,
      "definition": "{\n  m: T",
      "shape": {
        "type": "primitive",
        "definition": "{\n  m: T"
      }
    },
    {
      "name": "MonadLawWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 64,
      "definition": "{\n  leftUnit: LawCheck<{ input: any",
      "shape": {
        "type": "primitive",
        "definition": "{\n  leftUnit: LawCheck<{ input: any"
      }
    },
    {
      "name": "MonadLeftUnitWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 86,
      "definition": "{\n  input: any",
      "shape": {
        "type": "primitive",
        "definition": "{\n  input: any"
      }
    },
    {
      "name": "MonadRightUnitWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 94,
      "definition": "{\n  input: T",
      "shape": {
        "type": "primitive",
        "definition": "{\n  input: T"
      }
    },
    {
      "name": "Mono",
      "type": "type",
      "file": "src/order/Domain.ts",
      "line": 36,
      "definition": "{\n  source: CPO<A>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  source: CPO<A>"
      }
    },
    {
      "name": "Monoid",
      "type": "type",
      "file": "src/types/measured-fingertree.ts",
      "line": 10,
      "definition": "{ empty: M",
      "shape": {
        "type": "primitive",
        "definition": "{ empty: M"
      }
    },
    {
      "name": "MonoidFree",
      "type": "interface",
      "file": "src/types/optics-free.ts",
      "line": 71,
      "properties": [
        {
          "name": "empty",
          "optional": false,
          "type": "A; concat: (x: A, y: A) => A"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "empty",
            "optional": false,
            "type": "A; concat: (x: A, y: A) => A"
          }
        ]
      }
    },
    {
      "name": "MonoidHom",
      "type": "type",
      "file": "src/algebra/semiringlike/Monoid.ts",
      "line": 18,
      "definition": "{\n  source: FiniteMonoid<A>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  source: FiniteMonoid<A>"
      }
    },
    {
      "name": "Monotone",
      "type": "type",
      "file": "src/order/Poset.ts",
      "line": 27,
      "definition": "{\n  source: Poset<A>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  source: Poset<A>"
      }
    },
    {
      "name": "Moore",
      "type": "type",
      "file": "src/coalgebra/Coalgebra.ts",
      "line": 2,
      "definition": "{\n  carrier: X[]",
      "shape": {
        "type": "primitive",
        "definition": "{\n  carrier: X[]"
      }
    },
    {
      "name": "Mor",
      "type": "type",
      "file": "src/types/mini-finset.ts",
      "line": 39,
      "definition": "{\n  src: Obj",
      "shape": {
        "type": "primitive",
        "definition": "{\n  src: Obj"
      }
    },
    {
      "name": "Nat",
      "type": "interface",
      "file": "src/types/catkit-equivalence.ts",
      "line": 10,
      "properties": [
        {
          "name": "F",
          "optional": false,
          "type": "Functor<A_O,A_M,B_O,B_M>"
        },
        {
          "name": "G",
          "optional": false,
          "type": "Functor<A_O,A_M,B_O,B_M>"
        },
        {
          "name": "at",
          "optional": false,
          "type": "(a:A_O)=>B_M; // α_a : F a → G a"
        },
        {
          "name": "at",
          "optional": false,
          "type": "method",
          "signature": "(a:A_O)",
          "returnType": "B_M; // α_a : F a → G a"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "at",
            "optional": false,
            "type": "(a:A_O)=>B_M; // α_a : F a → G a"
          },
          {
            "name": "at",
            "optional": false,
            "type": "method"
          },
          {
            "name": "F",
            "optional": false,
            "type": "Functor<T>"
          },
          {
            "name": "G",
            "optional": false,
            "type": "Functor<T>"
          }
        ]
      }
    },
    {
      "name": "Nat1",
      "type": "type",
      "file": "src/category/Nat.ts",
      "line": 12,
      "definition": "<A>(fa: F) => G",
      "shape": {
        "type": "function",
        "signature": "<A>(fa: F) => G"
      }
    },
    {
      "name": "NatCo",
      "type": "interface",
      "file": "src/types/copresheaf.ts",
      "line": 18,
      "properties": [
        {
          "name": "at",
          "optional": false,
          "type": "(c: Obj<C>) => (x: any) => any; // component β_c : G(c) -> H(c)"
        },
        {
          "name": "at",
          "optional": false,
          "type": "method",
          "signature": "(c: Obj<C>)",
          "returnType": "(x: any) => any; // component β_c : G(c) -> H(c)"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "at",
            "optional": false,
            "type": "(c: Obj<T>) => (x: any) => any; // component β_c : G(c) -> H(c)"
          },
          {
            "name": "at",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "NatPsh",
      "type": "interface",
      "file": "src/types/presheaf.ts",
      "line": 18,
      "properties": [
        {
          "name": "at",
          "optional": false,
          "type": "(c: Obj<C>) => (x: any) => any; // component α_c : P(c) -> Q(c)"
        },
        {
          "name": "at",
          "optional": false,
          "type": "method",
          "signature": "(c: Obj<C>)",
          "returnType": "(x: any) => any; // component α_c : P(c) -> Q(c)"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "at",
            "optional": false,
            "type": "(c: Obj<T>) => (x: any) => any; // component α_c : P(c) -> Q(c)"
          },
          {
            "name": "at",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "NatTrans",
      "type": "interface",
      "file": "src/types/codensity-nat-bridge.ts",
      "line": 11,
      "properties": [
        {
          "name": "at",
          "optional": false,
          "type": "(b: B_O) => (k: (a: any) => any) => any"
        },
        {
          "name": "at",
          "optional": false,
          "type": "method",
          "signature": "(b: B_O)",
          "returnType": "(k: (a: any) => any) => any"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "at",
            "optional": false,
            "type": "(b: B_O) => (k: (a: any) => any) => any"
          },
          {
            "name": "at",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "NaturalityWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 51,
      "definition": "{\n  natural: boolean",
      "shape": {
        "type": "primitive",
        "definition": "{\n  natural: boolean"
      }
    },
    {
      "name": "Node",
      "type": "type",
      "file": "src/types/fingertree.ts",
      "line": 53,
      "definition": "| { tag: \"Node2\"",
      "shape": {
        "type": "primitive",
        "definition": "| { tag: \"Node2\""
      }
    },
    {
      "name": "NSimplex",
      "type": "type",
      "file": "src/types/category-to-nerve-sset.ts",
      "line": 110,
      "definition": "{ head: O",
      "shape": {
        "type": "primitive",
        "definition": "{ head: O"
      }
    },
    {
      "name": "Obj",
      "type": "type",
      "file": "src/types/sset-quasicat.ts",
      "line": 9,
      "definition": "string",
      "shape": {
        "type": "primitive",
        "definition": "string"
      }
    },
    {
      "name": "ObjPair",
      "type": "type",
      "file": "src/types/spec-impl.ts",
      "line": 17,
      "definition": "{ spec: Finite<A>, impl: Finite<Â>, surj: Surj<A,Â> }",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "spec",
            "optional": false,
            "type": "Finite<T>, impl: Finite<T>, surj: Surj<T>"
          }
        ]
      }
    },
    {
      "name": "OperationResult",
      "type": "interface",
      "file": "src/bench/rel-benchmark.ts",
      "line": 39,
      "properties": [
        {
          "name": "operation",
          "optional": false,
          "type": "string"
        },
        {
          "name": "implementation",
          "optional": false,
          "type": "\"Rel\" | \"BitRel\""
        },
        {
          "name": "size",
          "optional": false,
          "type": "number"
        },
        {
          "name": "density",
          "optional": false,
          "type": "number"
        },
        {
          "name": "timeMs",
          "optional": false,
          "type": "number"
        },
        {
          "name": "memoryBytes",
          "optional": true,
          "type": "number"
        },
        {
          "name": "pairCount",
          "optional": false,
          "type": "number"
        }
      ],
      "shape": {
        "propertyCount": 7,
        "properties": [
          {
            "name": "density",
            "optional": false,
            "type": "number"
          },
          {
            "name": "implementation",
            "optional": false,
            "type": "\"Rel\" | \"BitRel\""
          },
          {
            "name": "memoryBytes",
            "optional": true,
            "type": "number"
          },
          {
            "name": "operation",
            "optional": false,
            "type": "string"
          },
          {
            "name": "pairCount",
            "optional": false,
            "type": "number"
          },
          {
            "name": "size",
            "optional": false,
            "type": "number"
          },
          {
            "name": "timeMs",
            "optional": false,
            "type": "number"
          }
        ]
      }
    },
    {
      "name": "OpSym",
      "type": "type",
      "file": "src/universal/Signature.ts",
      "line": 1,
      "definition": "{ name: string",
      "shape": {
        "type": "primitive",
        "definition": "{ name: string"
      }
    },
    {
      "name": "OpticsBridge",
      "type": "interface",
      "file": "src/types/optics-profunctor-bridge-safe.ts",
      "line": 380,
      "properties": [
        {
          "name": "lens",
          "optional": false,
          "type": "SafeLens<S, A>"
        },
        {
          "name": "domain",
          "optional": false,
          "type": "{ elems: S[]"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "domain",
            "optional": false,
            "type": "{ elems: S[]"
          },
          {
            "name": "lens",
            "optional": false,
            "type": "SafeLens<T>"
          }
        ]
      }
    },
    {
      "name": "Option",
      "type": "type",
      "file": "src/types/strong-monad.ts",
      "line": 13,
      "definition": "{ tag: \"none\" } | { tag: \"some\"",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "tag",
            "optional": false,
            "type": "\"none\""
          }
        ]
      }
    },
    {
      "name": "OptionFree",
      "type": "type",
      "file": "src/types/optics-free.ts",
      "line": 128,
      "definition": "{ _tag: 'None' } | { _tag: 'Some'",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "_tag",
            "optional": false,
            "type": "'None'"
          }
        ]
      }
    },
    {
      "name": "P2Free",
      "type": "type",
      "file": "src/types/optics-free.ts",
      "line": 38,
      "definition": "Brand<(a: A) => B, 'P2'>",
      "shape": {
        "type": "function",
        "signature": "Brand<(a: A) => B, 'P2'>"
      }
    },
    {
      "name": "Pair",
      "type": "type",
      "file": "src/types/rel-equipment.ts",
      "line": 51,
      "definition": "readonly [A,B]",
      "shape": {
        "type": "primitive",
        "definition": "readonly [A,B]"
      }
    },
    {
      "name": "PairClass",
      "type": "type",
      "file": "src/types/category-to-nerve-sset.ts",
      "line": 1161,
      "definition": "{\n  rep: { b: B_O",
      "shape": {
        "type": "primitive",
        "definition": "{\n  rep: { b: B_O"
      }
    },
    {
      "name": "PairingScheme",
      "type": "interface",
      "file": "src/structures/group/pairing/PairingScheme.ts",
      "line": 4,
      "properties": [
        {
          "name": "pair",
          "optional": false,
          "type": "(a: A, b: B) => O"
        },
        {
          "name": "pair",
          "optional": false,
          "type": "method",
          "signature": "(a: A, b: B)",
          "returnType": "O"
        },
        {
          "name": "left",
          "optional": false,
          "type": "(o: O) => A"
        },
        {
          "name": "left",
          "optional": false,
          "type": "method",
          "signature": "(o: O)",
          "returnType": "A"
        },
        {
          "name": "right",
          "optional": false,
          "type": "(o: O) => B"
        },
        {
          "name": "right",
          "optional": false,
          "type": "method",
          "signature": "(o: O)",
          "returnType": "B"
        }
      ],
      "shape": {
        "propertyCount": 6,
        "properties": [
          {
            "name": "left",
            "optional": false,
            "type": "(o: O) => A"
          },
          {
            "name": "left",
            "optional": false,
            "type": "method"
          },
          {
            "name": "pair",
            "optional": false,
            "type": "(a: A, b: B) => O"
          },
          {
            "name": "pair",
            "optional": false,
            "type": "method"
          },
          {
            "name": "right",
            "optional": false,
            "type": "(o: O) => B"
          },
          {
            "name": "right",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "ParityMismatchWitness",
      "type": "interface",
      "file": "src/types/rel-parity-guards.ts",
      "line": 70,
      "properties": [
        {
          "name": "operation",
          "optional": false,
          "type": "string"
        },
        {
          "name": "inputs",
          "optional": false,
          "type": "{"
        },
        {
          "name": "relations",
          "optional": false,
          "type": "Array<{ pairs: Array<[any, any]>; A: any[]; B: any[]"
        }
      ],
      "shape": {
        "propertyCount": 3,
        "properties": [
          {
            "name": "inputs",
            "optional": false,
            "type": "{"
          },
          {
            "name": "operation",
            "optional": false,
            "type": "string"
          },
          {
            "name": "relations",
            "optional": false,
            "type": "{ pairs: Array<[any, any][]; A: any[]; B: any[]"
          }
        ]
      }
    },
    {
      "name": "Path",
      "type": "type",
      "file": "src/types/optics-rewrite.ts",
      "line": 352,
      "definition": "string[]",
      "shape": {
        "type": "primitive",
        "definition": "string[]"
      }
    },
    {
      "name": "PathMor",
      "type": "type",
      "file": "src/types/category-to-nerve-sset.ts",
      "line": 29,
      "definition": "{\n  readonly src: O",
      "shape": {
        "type": "primitive",
        "definition": "{\n  readonly src: O"
      }
    },
    {
      "name": "PerformanceMode",
      "type": "type",
      "file": "src/types/config.ts",
      "line": 14,
      "definition": "'development' | 'production'",
      "shape": {
        "type": "primitive",
        "definition": "'development' | 'production'"
      }
    },
    {
      "name": "PIsoFree",
      "type": "type",
      "file": "src/types/optics-free.ts",
      "line": 82,
      "definition": "(P: ProfunctorFree<any>) => (pab: (a: A) => B) => (s: S) => T",
      "shape": {
        "type": "function",
        "signature": "(P: ProfunctorFree<any>) => (pab: (a: A) => B) => (s: S) => T"
      }
    },
    {
      "name": "PLensFree",
      "type": "type",
      "file": "src/types/optics-free.ts",
      "line": 83,
      "definition": "(P: StrongFree<any>) => (pab: (a: A) => B) => (s: S) => T",
      "shape": {
        "type": "function",
        "signature": "(P: StrongFree<any>) => (pab: (a: A) => B) => (s: S) => T"
      }
    },
    {
      "name": "Poly",
      "type": "type",
      "file": "src/structures/ring/Poly.ts",
      "line": 4,
      "definition": "{ coeffs: number[]",
      "shape": {
        "type": "primitive",
        "definition": "{ coeffs: number[]"
      }
    },
    {
      "name": "POptic",
      "type": "type",
      "file": "src/types/advanced.ts",
      "line": 57,
      "definition": "(P: unknown) => (pab: HKT2Prof<P, A, B>) => HKT2Prof<P, S, T>\n\nexport type PIso<S, T, A, B> = <P>(P: Profunctor2<P>) => (pab: HKT2Prof<P, A, B>) => HKT2Prof<P, S, T>\nexport type PLens<S, T, A, B> = <P>(P: Strong<P>) => (pab: HKT2Prof<P, A, B>) => HKT2Prof<P, S, T>\nexport type PPrism<S, T, A, B> = <P>(P: Choice<P>) => (pab: HKT2Prof<P, A, B>) => HKT2Prof<P, S, T>\n// Traversal needs a stronger capability (Wander/Traversing). We'll add it below.\n\n// Smart constructors (simplified for type compatibility)\nexport const iso = <S, T, A, B>(\n  _get: (s: S) => A,\n  _rev: (b: B) => T\n): PIso<S, T, A, B> =>\n  unsafeCoerce((_P: unknown) => (pab: unknown) => pab)\n\n// LENS (simplified)\nexport const lens = <S, T, A, B>(\n  _get: (s: S) => A,\n  _set: (s: S, b: B) => T\n): PLens<S, T, A, B> =>\n  unsafeCoerce((_P: unknown) => (pab: unknown) => pab)\n\n// PRISM (simplified)\nexport const prism = <S, T, A, B>(\n  _match: (s: S) => Either<A, T>,     // Left: focus A, Right: already T\n  _build: (b: B) => T\n): PPrism<S, T, A, B> =>\n  unsafeCoerce((_P: unknown) => (pab: unknown) => pab)\n\n// ----- Running optics: concrete profunctors you'll actually use -----\n\n// Function profunctor instance\ntype PFN = 'PFN'\n// Function profunctor implementation (exported for potential use)\nexport const functionStrong: Strong<PFN> = {\n  dimap: (pab: unknown, l: unknown, r: unknown) => {\n    const pabFn = unsafeCoerce<unknown, (x: unknown) => unknown>(pab)",
      "shape": {
        "type": "function",
        "signature": "(P: unknown) => (pab: HKT2Prof<P, A, B>) => HKT2Prof<P, S, T>\n\nexport type PIso<S, T, A, B> = <P>(P: Profunctor2<P>) => (pab: HKT2Prof<P, A, B>) => HKT2Prof<P, S, T>\nexport type PLens<S, T, A, B> = <P>(P: Strong<P>) => (pab: HKT2Prof<P, A, B>) => HKT2Prof<P, S, T>\nexport type PPrism<S, T, A, B> = <P>(P: Choice<P>) => (pab: HKT2Prof<P, A, B>) => HKT2Prof<P, S, T>\n// Traversal needs a stronger capability (Wander/Traversing). We'll add it below.\n\n// Smart constructors (simplified for type compatibility)\nexport const iso = <S, T, A, B>(\n  _get: (s: S) => A,\n  _rev: (b: B) => T\n): PIso<S, T, A, B> =>\n  unsafeCoerce((_P: unknown) => (pab: unknown) => pab)\n\n// LENS (simplified)\nexport const lens = <S, T, A, B>(\n  _get: (s: S) => A,\n  _set: (s: S, b: B) => T\n): PLens<S, T, A, B> =>\n  unsafeCoerce((_P: unknown) => (pab: unknown) => pab)\n\n// PRISM (simplified)\nexport const prism = <S, T, A, B>(\n  _match: (s: S) => Either<A, T>,     // Left: focus A, Right: already T\n  _build: (b: B) => T\n): PPrism<S, T, A, B> =>\n  unsafeCoerce((_P: unknown) => (pab: unknown) => pab)\n\n// ----- Running optics: concrete profunctors you'll actually use -----\n\n// Function profunctor instance\ntype PFN = 'PFN'\n// Function profunctor implementation (exported for potential use)\nexport const functionStrong: Strong<PFN> = {\n  dimap: (pab: unknown, l: unknown, r: unknown) => {\n    const pabFn = unsafeCoerce<unknown, (x: unknown) => unknown>(pab)"
      }
    },
    {
      "name": "Poset",
      "type": "interface",
      "file": "src/types/catkit-posets.ts",
      "line": 16,
      "properties": [
        {
          "name": "leq",
          "optional": false,
          "type": "(x: T, y: T) => boolean; // reflexive & transitive assumed"
        },
        {
          "name": "leq",
          "optional": false,
          "type": "method",
          "signature": "(x: T, y: T)",
          "returnType": "boolean; // reflexive & transitive assumed"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "leq",
            "optional": false,
            "type": "(x: T, y: T) => boolean; // reflexive & transitive assumed"
          },
          {
            "name": "leq",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "PPrismFree",
      "type": "type",
      "file": "src/types/optics-free.ts",
      "line": 84,
      "definition": "(P: ChoiceFree<any>) => (pab: (a: A) => B) => (s: S) => T",
      "shape": {
        "type": "function",
        "signature": "(P: ChoiceFree<any>) => (pab: (a: A) => B) => (s: S) => T"
      }
    },
    {
      "name": "Presheaf",
      "type": "interface",
      "file": "src/types/presheaf.ts",
      "line": 12,
      "properties": [
        {
          "name": "onObj",
          "optional": false,
          "type": "(c: Obj<C>) => SetObj<any>"
        },
        {
          "name": "onObj",
          "optional": false,
          "type": "method",
          "signature": "(c: Obj<C>)",
          "returnType": "SetObj<any>"
        },
        {
          "name": "onMor",
          "optional": false,
          "type": "(f: Mor<C>) => (x: any) => any; // P(f): P(b) -> P(a)"
        },
        {
          "name": "onMor",
          "optional": false,
          "type": "method",
          "signature": "(f: Mor<C>)",
          "returnType": "(x: any) => any; // P(f): P(b) -> P(a)"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "onMor",
            "optional": false,
            "type": "(f: Mor<T>) => (x: any) => any; // P(f): P(b) -> P(a)"
          },
          {
            "name": "onMor",
            "optional": false,
            "type": "method"
          },
          {
            "name": "onObj",
            "optional": false,
            "type": "(c: Obj<T>) => SetObj<T>"
          },
          {
            "name": "onObj",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "Prime",
      "type": "type",
      "file": "src/structures/ring/Spec.ts",
      "line": 34,
      "definition": "Ideal<A> & { prime:true }",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "prime",
            "optional": false,
            "type": "true"
          }
        ]
      }
    },
    {
      "name": "Prism",
      "type": "type",
      "file": "src/types/optics-witness.ts",
      "line": 101,
      "definition": "{\n  match: (s:S)=> Option<A>",
      "shape": {
        "type": "function",
        "signature": "{\n  match: (s:S)=> Option<A>"
      }
    },
    {
      "name": "PrismLawReport",
      "type": "type",
      "file": "src/types/catkit-prisms.ts",
      "line": 118,
      "definition": "{\n  buildMatch: boolean",
      "shape": {
        "type": "primitive",
        "definition": "{\n  buildMatch: boolean"
      }
    },
    {
      "name": "PrismWitness",
      "type": "type",
      "file": "src/types/optics-witness.ts",
      "line": 106,
      "definition": "{\n  buildMatch: { ok:true } | { ok:false",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "buildMatch",
            "optional": false,
            "type": "{ ok:true"
          }
        ]
      }
    },
    {
      "name": "Prob",
      "type": "type",
      "file": "src/prob/Dist.ts",
      "line": 4,
      "definition": "number",
      "shape": {
        "type": "primitive",
        "definition": "number"
      }
    },
    {
      "name": "Prof",
      "type": "interface",
      "file": "src/types/catkit-adjunction.ts",
      "line": 101,
      "properties": [
        {
          "name": "elems",
          "optional": false,
          "type": "(a: A_O, b: B_O) => ReadonlyArray<T>"
        },
        {
          "name": "elems",
          "optional": false,
          "type": "method",
          "signature": "(a: A_O, b: B_O)",
          "returnType": "ReadonlyArray<T>"
        },
        {
          "name": "lmap",
          "optional": false,
          "type": "(u: A_M, b: B_O, t: T) => T; // contravariant in A"
        },
        {
          "name": "lmap",
          "optional": false,
          "type": "method",
          "signature": "(u: A_M, b: B_O, t: T)",
          "returnType": "T; // contravariant in A"
        },
        {
          "name": "rmap",
          "optional": false,
          "type": "(a: A_O, v: B_M, t: T) => T; // covariant in B"
        },
        {
          "name": "rmap",
          "optional": false,
          "type": "method",
          "signature": "(a: A_O, v: B_M, t: T)",
          "returnType": "T; // covariant in B"
        }
      ],
      "shape": {
        "propertyCount": 6,
        "properties": [
          {
            "name": "elems",
            "optional": false,
            "type": "(a: A_O, b: B_O) => ReadonlyT[]"
          },
          {
            "name": "elems",
            "optional": false,
            "type": "method"
          },
          {
            "name": "lmap",
            "optional": false,
            "type": "(u: A_M, b: B_O, t: T) => T; // contravariant in A"
          },
          {
            "name": "lmap",
            "optional": false,
            "type": "method"
          },
          {
            "name": "rmap",
            "optional": false,
            "type": "(a: A_O, v: B_M, t: T) => T; // covariant in B"
          },
          {
            "name": "rmap",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "ProfDict",
      "type": "interface",
      "file": "src/types/catkit-prisms.ts",
      "line": 18,
      "properties": [
        {
          "name": "dimap",
          "optional": false,
          "type": "<A,B,C,D>(p: PVal<P,A,B>, l:(c:C)=>A, r:(b:B)=>D) => PVal<P,C,D>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "dimap",
            "optional": false,
            "type": "<A,B,C,D>(p: PVal<T>, l:(c:C)=>A, r:(b:B)=>D) => PVal<T>"
          }
        ]
      }
    },
    {
      "name": "Profunctor",
      "type": "interface",
      "file": "src/types/functors.ts",
      "line": 42,
      "properties": [
        {
          "name": "dimap",
          "optional": false,
          "type": "<A, B, C, D>(pab: HKT<P, [A, B]>, l: (c: C) => A, r: (b: B) => D) => HKT<P, [C, D]>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "dimap",
            "optional": false,
            "type": "<A, B, C, D>(pab: HKT<T>, l: (c: C) => A, r: (b: B) => D) => HKT<T>"
          }
        ]
      }
    },
    {
      "name": "Profunctor2",
      "type": "interface",
      "file": "src/types/advanced.ts",
      "line": 38,
      "properties": [
        {
          "name": "dimap",
          "optional": false,
          "type": "<A, B, C, D>(pab: HKT2Prof<P, A, B>, l: (c: C) => A, r: (b: B) => D) => HKT2Prof<P, C, D>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "dimap",
            "optional": false,
            "type": "<A, B, C, D>(pab: HKT2Prof<T>, l: (c: C) => A, r: (b: B) => D) => HKT2Prof<T>"
          }
        ]
      }
    },
    {
      "name": "ProfunctorFree",
      "type": "interface",
      "file": "src/types/optics-free.ts",
      "line": 40,
      "properties": [
        {
          "name": "dimap",
          "optional": false,
          "type": "(pab: any, l: any, r: any) => any"
        },
        {
          "name": "dimap",
          "optional": false,
          "type": "method",
          "signature": "(pab: any, l: any, r: any)",
          "returnType": "any"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "dimap",
            "optional": false,
            "type": "(pab: any, l: any, r: any) => any"
          },
          {
            "name": "dimap",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "ProfunctorLens",
      "type": "type",
      "file": "src/types/optics-witness.ts",
      "line": 170,
      "definition": "{\n  _tag: \"Lens\"",
      "shape": {
        "type": "primitive",
        "definition": "{\n  _tag: \"Lens\""
      }
    },
    {
      "name": "ProfunctorPrism",
      "type": "type",
      "file": "src/types/optics-witness.ts",
      "line": 176,
      "definition": "{\n  _tag: \"Prism\"",
      "shape": {
        "type": "primitive",
        "definition": "{\n  _tag: \"Prism\""
      }
    },
    {
      "name": "ProfunctorTraversal",
      "type": "type",
      "file": "src/types/optics-profunctor-bridge-safe.ts",
      "line": 46,
      "definition": "Brand<{\n  readonly _tag: 'ProfunctorTraversal'",
      "shape": {
        "type": "primitive",
        "definition": "Brand<{\n  readonly _tag: 'ProfunctorTraversal'"
      }
    },
    {
      "name": "ProTrans",
      "type": "interface",
      "file": "src/types/category-to-nerve-sset.ts",
      "line": 1101,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "PTraversal",
      "type": "type",
      "file": "src/types/advanced.ts",
      "line": 199,
      "definition": "<P>(P: Wander<P>) => (pab: HKT2Prof<P, A, B>) => HKT2Prof<P, S, T>\n\nexport const each = <A, B>(): PTraversal<ReadonlyArray<A>, ReadonlyArray<B>, A, B> =>\n  <P>(P: Wander<P>) =>\n    (pab: HKT2Prof<P, A, B>) =>\n      P.wander(arrayApplicative)(\n        (as: unknown, f: unknown) => {\n          const arr = unsafeCoerce<unknown, ReadonlyArray<A>>(as)",
      "shape": {
        "type": "function",
        "signature": "<P>(P: Wander<P>) => (pab: HKT2Prof<P, A, B>) => HKT2Prof<P, S, T>\n\nexport const each = <A, B>(): PTraversal<ReadonlyArray<A>, ReadonlyArray<B>, A, B> =>\n  <P>(P: Wander<P>) =>\n    (pab: HKT2Prof<P, A, B>) =>\n      P.wander(arrayApplicative)(\n        (as: unknown, f: unknown) => {\n          const arr = unsafeCoerce<unknown, ReadonlyArray<A>>(as)"
      }
    },
    {
      "name": "PTraversalFree",
      "type": "type",
      "file": "src/types/optics-free.ts",
      "line": 189,
      "definition": "<P>(P: WanderFree<P>) => (pab: (a: A) => B) => (s: S) => T",
      "shape": {
        "type": "function",
        "signature": "<P>(P: WanderFree<P>) => (pab: (a: A) => B) => (s: S) => T"
      }
    },
    {
      "name": "Pure",
      "type": "interface",
      "file": "src/types/advanced.ts",
      "line": 316,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "PushoutResult",
      "type": "interface",
      "file": "src/types/quiver-pushout.ts",
      "line": 34,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "PVal",
      "type": "type",
      "file": "src/types/catkit-prisms.ts",
      "line": 17,
      "definition": "any",
      "shape": {
        "type": "primitive",
        "definition": "any"
      }
    },
    {
      "name": "QCReport",
      "type": "type",
      "file": "src/types/sset-quasicat.ts",
      "line": 297,
      "definition": "{\n  nMax: number",
      "shape": {
        "type": "primitive",
        "definition": "{\n  nMax: number"
      }
    },
    {
      "name": "Quiver",
      "type": "interface",
      "file": "src/types/category-to-nerve-sset.ts",
      "line": 22,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "QuiverMorphism",
      "type": "interface",
      "file": "src/types/quiver-pushout.ts",
      "line": 16,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "Rational",
      "type": "type",
      "file": "src/number/Rational.ts",
      "line": 2,
      "definition": "{ n: bigint",
      "shape": {
        "type": "primitive",
        "definition": "{ n: bigint"
      }
    },
    {
      "name": "Reader",
      "type": "type",
      "file": "src/types/strong-monad.ts",
      "line": 72,
      "definition": "(r: R) => A",
      "shape": {
        "type": "function",
        "signature": "(r: R) => A"
      }
    },
    {
      "name": "ReaderLens",
      "type": "type",
      "file": "src/types/freeapp-coyo.ts",
      "line": 176,
      "definition": "{ get(s: S): T",
      "shape": {
        "type": "primitive",
        "definition": "{ get(s: S): T"
      }
    },
    {
      "name": "Rel",
      "type": "type",
      "file": "src/types/category-to-nerve-sset.ts",
      "line": 761,
      "definition": "{\n  src: SetObj<any>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  src: SetObj<any>"
      }
    },
    {
      "name": "RelationalLawResults",
      "type": "type",
      "file": "src/types/rel-lawcheck.ts",
      "line": 50,
      "definition": "{\n  residualLaws: {\n    leftAdjunction: Array<LawCheck<ResidualAdjunctionWitness<any, any, any>>>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  residualLaws: {\n    leftAdjunction: Array<LawCheck<ResidualAdjunctionWitness<any, any, any>>>"
      }
    },
    {
      "name": "RelEqWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 15,
      "definition": "| { equal: true",
      "shape": {
        "type": "primitive",
        "definition": "| { equal: true"
      }
    },
    {
      "name": "RelFactory",
      "type": "interface",
      "file": "src/types/rel-common.ts",
      "line": 101,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "RelImpl",
      "type": "type",
      "file": "src/types/config.ts",
      "line": 5,
      "definition": "'naive' | 'bit'",
      "shape": {
        "type": "primitive",
        "definition": "'naive' | 'bit'"
      }
    },
    {
      "name": "RelStrategy",
      "type": "type",
      "file": "src/types/rel-common.ts",
      "line": 99,
      "definition": "'naive' | 'bit'",
      "shape": {
        "type": "primitive",
        "definition": "'naive' | 'bit'"
      }
    },
    {
      "name": "ResidualAdjunctionWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 141,
      "definition": "{\n  R: any",
      "shape": {
        "type": "primitive",
        "definition": "{\n  R: any"
      }
    },
    {
      "name": "RewritePrism",
      "type": "interface",
      "file": "src/types/optics-rewrite.ts",
      "line": 14,
      "properties": [
        {
          "name": "modify",
          "optional": false,
          "type": "(s: S, f: (a: A) => A) => S;       // default via preview/review"
        },
        {
          "name": "modify",
          "optional": false,
          "type": "method",
          "signature": "(s: S, f: (a: A)",
          "returnType": "A) => S;       // default via preview/review"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "modify",
            "optional": false,
            "type": "(s: S, f: (a: A) => A) => S; // default via preview/review"
          },
          {
            "name": "modify",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "RewriteRule",
      "type": "type",
      "file": "src/universal/rewrite/Rules.ts",
      "line": 6,
      "definition": "{\n  lhs: Term",
      "shape": {
        "type": "primitive",
        "definition": "{\n  lhs: Term"
      }
    },
    {
      "name": "Ring",
      "type": "interface",
      "file": "src/laws/examples/ESLintDemo.ts",
      "line": 31,
      "properties": [
        {
          "name": "add",
          "optional": false,
          "type": "(x: A, y: A) => A"
        },
        {
          "name": "add",
          "optional": false,
          "type": "method",
          "signature": "(x: A, y: A)",
          "returnType": "A"
        },
        {
          "name": "mul",
          "optional": false,
          "type": "(x: A, y: A) => A"
        },
        {
          "name": "mul",
          "optional": false,
          "type": "method",
          "signature": "(x: A, y: A)",
          "returnType": "A"
        },
        {
          "name": "zero",
          "optional": false,
          "type": "A"
        },
        {
          "name": "one",
          "optional": false,
          "type": "A"
        }
      ],
      "shape": {
        "propertyCount": 6,
        "properties": [
          {
            "name": "add",
            "optional": false,
            "type": "(x: A, y: A) => A"
          },
          {
            "name": "add",
            "optional": false,
            "type": "method"
          },
          {
            "name": "mul",
            "optional": false,
            "type": "(x: A, y: A) => A"
          },
          {
            "name": "mul",
            "optional": false,
            "type": "method"
          },
          {
            "name": "one",
            "optional": false,
            "type": "A"
          },
          {
            "name": "zero",
            "optional": false,
            "type": "A"
          }
        ]
      }
    },
    {
      "name": "RingEq",
      "type": "type",
      "file": "src/structures/ring/Ring.ts",
      "line": 3,
      "definition": "Eq<A>",
      "shape": {
        "type": "primitive",
        "definition": "Eq<A>"
      }
    },
    {
      "name": "RingHom",
      "type": "type",
      "file": "src/structures/ring/RingHom.ts",
      "line": 3,
      "definition": "{\n  source: FiniteRing<A>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  source: FiniteRing<A>"
      }
    },
    {
      "name": "RingWitnesses",
      "type": "interface",
      "file": "src/algebra/ring/Hom.ts",
      "line": 12,
      "properties": [
        {
          "name": "isHom",
          "optional": false,
          "type": "boolean;                 // preserves add,mul,0,1"
        },
        {
          "name": "injectiveUnderlying",
          "optional": false,
          "type": "boolean;   // injective as a function of sets"
        },
        {
          "name": "surjectiveUnderlying",
          "optional": false,
          "type": "boolean;  // surjective as a function of sets"
        },
        {
          "name": "isMono",
          "optional": false,
          "type": "boolean;                // left-cancellable (checked by probing)"
        },
        {
          "name": "isEpi",
          "optional": false,
          "type": "boolean;                 // right-cancellable (checked by probing)"
        },
        {
          "name": "isIso",
          "optional": false,
          "type": "boolean;                 // has two-sided inverse hom (found by search)"
        },
        {
          "name": "leftInverse",
          "optional": true,
          "type": "RingHom<B,A>"
        },
        {
          "name": "rightInverse",
          "optional": true,
          "type": "RingHom<B,A>"
        }
      ],
      "shape": {
        "propertyCount": 8,
        "properties": [
          {
            "name": "injectiveUnderlying",
            "optional": false,
            "type": "boolean; // injective as a function of sets"
          },
          {
            "name": "isEpi",
            "optional": false,
            "type": "boolean; // right-cancellable (checked by probing)"
          },
          {
            "name": "isHom",
            "optional": false,
            "type": "boolean; // preserves add,mul,0,1"
          },
          {
            "name": "isIso",
            "optional": false,
            "type": "boolean; // has two-sided inverse hom (found by search)"
          },
          {
            "name": "isMono",
            "optional": false,
            "type": "boolean; // left-cancellable (checked by probing)"
          },
          {
            "name": "leftInverse",
            "optional": true,
            "type": "RingHom<T>"
          },
          {
            "name": "rightInverse",
            "optional": true,
            "type": "RingHom<T>"
          },
          {
            "name": "surjectiveUnderlying",
            "optional": false,
            "type": "boolean; // surjective as a function of sets"
          }
        ]
      }
    },
    {
      "name": "Rope",
      "type": "type",
      "file": "src/types/rope.ts",
      "line": 16,
      "definition": "MeasuredFingerTree<string, number>",
      "shape": {
        "type": "primitive",
        "definition": "MeasuredFingerTree<string, number>"
      }
    },
    {
      "name": "Rose",
      "type": "type",
      "file": "src/types/adt-rose.ts",
      "line": 27,
      "definition": "Fix<RoseF<any, A>>",
      "shape": {
        "type": "primitive",
        "definition": "Fix<RoseF<any, A>>"
      }
    },
    {
      "name": "RoseF",
      "type": "type",
      "file": "src/types/adt-rose.ts",
      "line": 7,
      "definition": "{ label: A",
      "shape": {
        "type": "primitive",
        "definition": "{ label: A"
      }
    },
    {
      "name": "Rule",
      "type": "type",
      "file": "src/types/optics-rewrite.ts",
      "line": 157,
      "definition": "{ name: string",
      "shape": {
        "type": "primitive",
        "definition": "{ name: string"
      }
    },
    {
      "name": "SafeGetter",
      "type": "type",
      "file": "src/types/optics-profunctor-bridge-safe.ts",
      "line": 15,
      "definition": "Brand<{\n  readonly get: (s: S) => A",
      "shape": {
        "type": "function",
        "signature": "Brand<{\n  readonly get: (s: S) => A"
      }
    },
    {
      "name": "SafeLens",
      "type": "type",
      "file": "src/types/optics-profunctor-bridge-safe.ts",
      "line": 19,
      "definition": "Brand<{\n  readonly get: (s: S) => A",
      "shape": {
        "type": "function",
        "signature": "Brand<{\n  readonly get: (s: S) => A"
      }
    },
    {
      "name": "SafePrism",
      "type": "type",
      "file": "src/types/optics-profunctor-bridge-safe.ts",
      "line": 24,
      "definition": "Brand<{\n  readonly match: (s: S) => A | undefined",
      "shape": {
        "type": "function",
        "signature": "Brand<{\n  readonly match: (s: S) => A | undefined"
      }
    },
    {
      "name": "SafeTraversal",
      "type": "type",
      "file": "src/types/optics-profunctor-bridge-safe.ts",
      "line": 29,
      "definition": "Brand<{\n  readonly modify: (s: S, f: (a: A) => A) => S",
      "shape": {
        "type": "function",
        "signature": "Brand<{\n  readonly modify: (s: S, f: (a: A) => A) => S"
      }
    },
    {
      "name": "SecondIsoResult",
      "type": "interface",
      "file": "src/algebra/group/SecondIso.ts",
      "line": 10,
      "properties": [
        {
          "name": "A_cap_N",
          "optional": false,
          "type": "Subgroup<A>"
        },
        {
          "name": "AN",
          "optional": false,
          "type": "Subgroup<A>"
        },
        {
          "name": "quotient_AN_mod_N",
          "optional": false,
          "type": "Group<any>"
        },
        {
          "name": "target_in_GmodN",
          "optional": false,
          "type": "Group<any>; // im(π∘i) ≤ G/N"
        },
        {
          "name": "iso",
          "optional": false,
          "type": "GroupIso<any, any>;     // A/(A∩N) ≅ im(π∘i)  (canonically equals (AN)/N)"
        }
      ],
      "shape": {
        "propertyCount": 5,
        "properties": [
          {
            "name": "A_cap_N",
            "optional": false,
            "type": "Subgroup<T>"
          },
          {
            "name": "AN",
            "optional": false,
            "type": "Subgroup<T>"
          },
          {
            "name": "iso",
            "optional": false,
            "type": "GroupIso<T>; // A/(A∩N) ≅ im(π∘i) (canonically equals (AN)/N)"
          },
          {
            "name": "quotient_AN_mod_N",
            "optional": false,
            "type": "Group<T>"
          },
          {
            "name": "target_in_GmodN",
            "optional": false,
            "type": "Group<T>; // im(π∘i) ≤ G/N"
          }
        ]
      }
    },
    {
      "name": "Semigroup",
      "type": "interface",
      "file": "src/types/algebraic.ts",
      "line": 22,
      "properties": [
        {
          "name": "concat",
          "optional": false,
          "type": "(x: A, y: A) => A"
        },
        {
          "name": "concat",
          "optional": false,
          "type": "method",
          "signature": "(x: A, y: A)",
          "returnType": "A"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "concat",
            "optional": false,
            "type": "(x: A, y: A) => A"
          },
          {
            "name": "concat",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "Semigroupoid",
      "type": "interface",
      "file": "src/types/algebraic.ts",
      "line": 68,
      "properties": [
        {
          "name": "compose",
          "optional": false,
          "type": "<A, B, C>(bc: Fn<B, C>, ab: Fn<A, B>) => Fn<A, C>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "compose",
            "optional": false,
            "type": "<A, B, C>(bc: Fn<T>, ab: Fn<T>) => Fn<T>"
          }
        ]
      }
    },
    {
      "name": "Semiring",
      "type": "interface",
      "file": "src/types/algebraic.ts",
      "line": 32,
      "properties": [
        {
          "name": "add",
          "optional": false,
          "type": "(x: A, y: A) => A"
        },
        {
          "name": "add",
          "optional": false,
          "type": "method",
          "signature": "(x: A, y: A)",
          "returnType": "A"
        },
        {
          "name": "zero",
          "optional": false,
          "type": "A"
        },
        {
          "name": "mul",
          "optional": false,
          "type": "(x: A, y: A) => A"
        },
        {
          "name": "mul",
          "optional": false,
          "type": "method",
          "signature": "(x: A, y: A)",
          "returnType": "A"
        },
        {
          "name": "one",
          "optional": false,
          "type": "A"
        }
      ],
      "shape": {
        "propertyCount": 6,
        "properties": [
          {
            "name": "add",
            "optional": false,
            "type": "(x: A, y: A) => A"
          },
          {
            "name": "add",
            "optional": false,
            "type": "method"
          },
          {
            "name": "mul",
            "optional": false,
            "type": "(x: A, y: A) => A"
          },
          {
            "name": "mul",
            "optional": false,
            "type": "method"
          },
          {
            "name": "one",
            "optional": false,
            "type": "A"
          },
          {
            "name": "zero",
            "optional": false,
            "type": "A"
          }
        ]
      }
    },
    {
      "name": "SetFunctor",
      "type": "interface",
      "file": "src/types/catkit-kan.ts",
      "line": 21,
      "properties": [
        {
          "name": "obj",
          "optional": false,
          "type": "(c: C_O) => SetObj<any>"
        },
        {
          "name": "obj",
          "optional": false,
          "type": "method",
          "signature": "(c: C_O)",
          "returnType": "SetObj<any>"
        },
        {
          "name": "map",
          "optional": false,
          "type": "(u: C_M) => (x:any)=>any; // H(u): H(c) → H(c')"
        },
        {
          "name": "map",
          "optional": false,
          "type": "method",
          "signature": "(u: C_M)",
          "returnType": "(x:any)=>any; // H(u): H(c) → H(c')"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "map",
            "optional": false,
            "type": "(u: C_M) => (x:any)=>any; // H(u): H(c) → H(c')"
          },
          {
            "name": "map",
            "optional": false,
            "type": "method"
          },
          {
            "name": "obj",
            "optional": false,
            "type": "(c: C_O) => SetObj<T>"
          },
          {
            "name": "obj",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "SetHom",
      "type": "interface",
      "file": "src/cat/set/SetCat.ts",
      "line": 24,
      "properties": [
        {
          "name": "witnesses",
          "optional": true,
          "type": "SetWitnesses<A,B>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "witnesses",
            "optional": true,
            "type": "SetWitnesses<T>"
          }
        ]
      }
    },
    {
      "name": "SetMonad",
      "type": "interface",
      "file": "src/universal/rewrite/SetMonad.ts",
      "line": 22,
      "properties": [
        {
          "name": "unit",
          "optional": false,
          "type": "(x: A) => FreeAlgebra<A>"
        },
        {
          "name": "unit",
          "optional": false,
          "type": "method",
          "signature": "(x: A)",
          "returnType": "FreeAlgebra<A>"
        },
        {
          "name": "multiply",
          "optional": false,
          "type": "(ttx: FreeAlgebra<FreeAlgebra<A>>) => FreeAlgebra<A>"
        },
        {
          "name": "multiply",
          "optional": false,
          "type": "method",
          "signature": "(ttx: FreeAlgebra<FreeAlgebra<A>>)",
          "returnType": "FreeAlgebra<A>"
        },
        {
          "name": "map",
          "optional": false,
          "type": "<B>(f: (a: A) => B) => (ta: FreeAlgebra<A>) => FreeAlgebra<B>"
        },
        {
          "name": "bind",
          "optional": false,
          "type": "<B>(ta: FreeAlgebra<A>, f: (a: A) => FreeAlgebra<B>) => FreeAlgebra<B>"
        }
      ],
      "shape": {
        "propertyCount": 6,
        "properties": [
          {
            "name": "bind",
            "optional": false,
            "type": "<B>(ta: FreeAlgebra<T>, f: (a: A) => FreeAlgebra<T>) => FreeAlgebra<T>"
          },
          {
            "name": "map",
            "optional": false,
            "type": "<B>(f: (a: A) => B) => (ta: FreeAlgebra<T>) => FreeAlgebra<T>"
          },
          {
            "name": "multiply",
            "optional": false,
            "type": "(ttx: FreeAlgebra<T>>) => FreeAlgebra<T>"
          },
          {
            "name": "multiply",
            "optional": false,
            "type": "method"
          },
          {
            "name": "unit",
            "optional": false,
            "type": "(x: A) => FreeAlgebra<T>"
          },
          {
            "name": "unit",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "SetMonadFromTheory",
      "type": "interface",
      "file": "src/universal/monad/LawvereMonad.ts",
      "line": 27,
      "properties": [
        {
          "name": "eta",
          "optional": false,
          "type": "<A>(X: FiniteSet<A>) => (x: A) => Term"
        },
        {
          "name": "mu",
          "optional": false,
          "type": "<A>(X: FiniteSet<A>) => (ttx: Term) => Term"
        },
        {
          "name": "bind",
          "optional": false,
          "type": "<A, B>(X: FiniteSet<A>, Y: FiniteSet<B>) => (tx: Term, f: (x: A) => Term) => Term"
        },
        {
          "name": "Tcarrier",
          "optional": false,
          "type": "<A>(X: FiniteSet<A>) => TCarrier<A>"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "bind",
            "optional": false,
            "type": "<A, B>(X: FiniteSet<T>, Y: FiniteSet<T>) => (tx: Term, f: (x: A) => Term) => Term"
          },
          {
            "name": "eta",
            "optional": false,
            "type": "<A>(X: FiniteSet<T>) => (x: A) => Term"
          },
          {
            "name": "mu",
            "optional": false,
            "type": "<A>(X: FiniteSet<T>) => (ttx: Term) => Term"
          },
          {
            "name": "Tcarrier",
            "optional": false,
            "type": "<A>(X: FiniteSet<T>) => TCarrier<T>"
          }
        ]
      }
    },
    {
      "name": "SetNat",
      "type": "interface",
      "file": "src/types/catkit-kan-transport.ts",
      "line": 27,
      "properties": [
        {
          "name": "F",
          "optional": false,
          "type": "SetFunctor<O,M>"
        },
        {
          "name": "G",
          "optional": false,
          "type": "SetFunctor<O,M>"
        },
        {
          "name": "at",
          "optional": false,
          "type": "(o:O) => (x:any)=>any"
        },
        {
          "name": "at",
          "optional": false,
          "type": "method",
          "signature": "(o:O)",
          "returnType": "(x:any)=>any"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "at",
            "optional": false,
            "type": "(o:O) => (x:any)=>any"
          },
          {
            "name": "at",
            "optional": false,
            "type": "method"
          },
          {
            "name": "F",
            "optional": false,
            "type": "SetFunctor<T>"
          },
          {
            "name": "G",
            "optional": false,
            "type": "SetFunctor<T>"
          }
        ]
      }
    },
    {
      "name": "SetObj",
      "type": "type",
      "file": "src/types/catkit-kan.ts",
      "line": 27,
      "definition": "{ id: string",
      "shape": {
        "type": "primitive",
        "definition": "{ id: string"
      }
    },
    {
      "name": "SetValuedFunctor",
      "type": "type",
      "file": "src/types/codensity-set.ts",
      "line": 21,
      "definition": "SetFunctor<B_O, B_M>",
      "shape": {
        "type": "primitive",
        "definition": "SetFunctor<B_O, B_M>"
      }
    },
    {
      "name": "SetWitnesses",
      "type": "interface",
      "file": "src/cat/set/SetCat.ts",
      "line": 32,
      "properties": [
        {
          "name": "isTotal",
          "optional": false,
          "type": "true;                         // by construction"
        },
        {
          "name": "injective",
          "optional": false,
          "type": "boolean;                    // underlying function injective"
        },
        {
          "name": "surjective",
          "optional": false,
          "type": "boolean;                   // underlying function surjective"
        },
        {
          "name": "bijective",
          "optional": false,
          "type": "boolean;                    // injective && surjective"
        },
        {
          "name": "isMono",
          "optional": false,
          "type": "boolean;                       // left-cancellable (== injective in Set)"
        },
        {
          "name": "isEpi",
          "optional": false,
          "type": "boolean;                        // right-cancellable (== surjective in Set)"
        },
        {
          "name": "inverse",
          "optional": true,
          "type": "SetHom<B,A>;                 // present iff bijective"
        }
      ],
      "shape": {
        "propertyCount": 7,
        "properties": [
          {
            "name": "bijective",
            "optional": false,
            "type": "boolean; // injective && surjective"
          },
          {
            "name": "injective",
            "optional": false,
            "type": "boolean; // underlying function injective"
          },
          {
            "name": "inverse",
            "optional": true,
            "type": "SetHom<T>; // present iff bijective"
          },
          {
            "name": "isEpi",
            "optional": false,
            "type": "boolean; // right-cancellable (== surjective in Set)"
          },
          {
            "name": "isMono",
            "optional": false,
            "type": "boolean; // left-cancellable (== injective in Set)"
          },
          {
            "name": "isTotal",
            "optional": false,
            "type": "true; // by construction"
          },
          {
            "name": "surjective",
            "optional": false,
            "type": "boolean; // underlying function surjective"
          }
        ]
      }
    },
    {
      "name": "Show",
      "type": "interface",
      "file": "src/types/algebraic.ts",
      "line": 13,
      "properties": [
        {
          "name": "show",
          "optional": false,
          "type": "(a: A) => string"
        },
        {
          "name": "show",
          "optional": false,
          "type": "method",
          "signature": "(a: A)",
          "returnType": "string"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "show",
            "optional": false,
            "type": "(a: A) => string"
          },
          {
            "name": "show",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "ShrinkResult",
      "type": "interface",
      "file": "src/types/property-shrinking.ts",
      "line": 14,
      "properties": [
        {
          "name": "minimal",
          "optional": false,
          "type": "T"
        },
        {
          "name": "shrinkSteps",
          "optional": false,
          "type": "number"
        },
        {
          "name": "originalSize",
          "optional": false,
          "type": "number"
        },
        {
          "name": "minimalSize",
          "optional": false,
          "type": "number"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "minimal",
            "optional": false,
            "type": "T"
          },
          {
            "name": "minimalSize",
            "optional": false,
            "type": "number"
          },
          {
            "name": "originalSize",
            "optional": false,
            "type": "number"
          },
          {
            "name": "shrinkSteps",
            "optional": false,
            "type": "number"
          }
        ]
      }
    },
    {
      "name": "ShrinkStrategy",
      "type": "type",
      "file": "src/types/property-shrinking.ts",
      "line": 11,
      "definition": "(witness: T) => T[]",
      "shape": {
        "type": "function",
        "signature": "(witness: T) => T[]"
      }
    },
    {
      "name": "Signature",
      "type": "type",
      "file": "src/universal/Signature.ts",
      "line": 3,
      "definition": "{\n  /** Operation symbols with fixed arity. Names must be unique. */\n  ops: OpSym[]",
      "shape": {
        "type": "primitive",
        "definition": "{\n  /** Operation symbols with fixed arity. Names must be unique. */\n  ops: OpSym[]"
      }
    },
    {
      "name": "SimplicialSet",
      "type": "interface",
      "file": "src/types/category-to-nerve-sset.ts",
      "line": 112,
      "properties": [
        {
          "name": "vertex",
          "optional": false,
          "type": "(o: O) => NSimplex<O, M>;                         // 0-simplex"
        },
        {
          "name": "vertex",
          "optional": false,
          "type": "method",
          "signature": "(o: O)",
          "returnType": "NSimplex<O, M>;                         // 0-simplex"
        },
        {
          "name": "simplex",
          "optional": false,
          "type": "(head: O, chain: ReadonlyArray<M>) => NSimplex<O, M>; // build with validation"
        },
        {
          "name": "simplex",
          "optional": false,
          "type": "method",
          "signature": "(head: O, chain: ReadonlyArray<M>)",
          "returnType": "NSimplex<O, M>; // build with validation"
        },
        {
          "name": "dim",
          "optional": false,
          "type": "(s: NSimplex<O, M>) => number;                      // n"
        },
        {
          "name": "dim",
          "optional": false,
          "type": "method",
          "signature": "(s: NSimplex<O, M>)",
          "returnType": "number;                      // n"
        },
        {
          "name": "objectsOf",
          "optional": false,
          "type": "(s: NSimplex<O, M>) => O[];                   // x0..xn"
        },
        {
          "name": "objectsOf",
          "optional": false,
          "type": "method",
          "signature": "(s: NSimplex<O, M>)",
          "returnType": "O[];                   // x0..xn"
        },
        {
          "name": "d",
          "optional": false,
          "type": "(i: number, s: NSimplex<O, M>) => NSimplex<O, M>;     // 0 ≤ i ≤ n"
        },
        {
          "name": "d",
          "optional": false,
          "type": "method",
          "signature": "(i: number, s: NSimplex<O, M>)",
          "returnType": "NSimplex<O, M>;     // 0 ≤ i ≤ n"
        },
        {
          "name": "s",
          "optional": false,
          "type": "(i: number, s: NSimplex<O, M>) => NSimplex<O, M>;     // 0 ≤ i ≤ n"
        },
        {
          "name": "s",
          "optional": false,
          "type": "method",
          "signature": "(i: number, s: NSimplex<O, M>)",
          "returnType": "NSimplex<O, M>;     // 0 ≤ i ≤ n"
        }
      ],
      "shape": {
        "propertyCount": 12,
        "properties": [
          {
            "name": "d",
            "optional": false,
            "type": "(i: number, s: NSimplex<T>) => NSimplex<T>; // 0 ≤ i ≤ n"
          },
          {
            "name": "d",
            "optional": false,
            "type": "method"
          },
          {
            "name": "dim",
            "optional": false,
            "type": "(s: NSimplex<T>) => number; // n"
          },
          {
            "name": "dim",
            "optional": false,
            "type": "method"
          },
          {
            "name": "objectsOf",
            "optional": false,
            "type": "(s: NSimplex<T>) => O[]; // x0..xn"
          },
          {
            "name": "objectsOf",
            "optional": false,
            "type": "method"
          },
          {
            "name": "s",
            "optional": false,
            "type": "(i: number, s: NSimplex<T>) => NSimplex<T>; // 0 ≤ i ≤ n"
          },
          {
            "name": "s",
            "optional": false,
            "type": "method"
          },
          {
            "name": "simplex",
            "optional": false,
            "type": "(head: O, chain: ReadonlyM[]) => NSimplex<T>; // build with validation"
          },
          {
            "name": "simplex",
            "optional": false,
            "type": "method"
          },
          {
            "name": "vertex",
            "optional": false,
            "type": "(o: O) => NSimplex<T>; // 0-simplex"
          },
          {
            "name": "vertex",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "SmallCategory",
      "type": "interface",
      "file": "src/types/category-to-nerve-sset.ts",
      "line": 11,
      "properties": [
        {
          "name": "id",
          "optional": false,
          "type": "(o: O) => M;                 // identity at o"
        },
        {
          "name": "id",
          "optional": false,
          "type": "method",
          "signature": "(o: O)",
          "returnType": "M;                 // identity at o"
        },
        {
          "name": "src",
          "optional": false,
          "type": "(m: M) => O;                 // domain of m"
        },
        {
          "name": "src",
          "optional": false,
          "type": "method",
          "signature": "(m: M)",
          "returnType": "O;                 // domain of m"
        },
        {
          "name": "dst",
          "optional": false,
          "type": "(m: M) => O;                 // codomain of m"
        },
        {
          "name": "dst",
          "optional": false,
          "type": "method",
          "signature": "(m: M)",
          "returnType": "O;                 // codomain of m"
        },
        {
          "name": "compose",
          "optional": false,
          "type": "(g: M, f: M) => M;           // g ∘ f, requires dst(f) = src(g)"
        },
        {
          "name": "compose",
          "optional": false,
          "type": "method",
          "signature": "(g: M, f: M)",
          "returnType": "M;           // g ∘ f, requires dst(f) = src(g)"
        }
      ],
      "shape": {
        "propertyCount": 8,
        "properties": [
          {
            "name": "compose",
            "optional": false,
            "type": "(g: M, f: M) => M; // g ∘ f, requires dst(f) = src(g)"
          },
          {
            "name": "compose",
            "optional": false,
            "type": "method"
          },
          {
            "name": "dst",
            "optional": false,
            "type": "(m: M) => O; // codomain of m"
          },
          {
            "name": "dst",
            "optional": false,
            "type": "method"
          },
          {
            "name": "id",
            "optional": false,
            "type": "(o: O) => M; // identity at o"
          },
          {
            "name": "id",
            "optional": false,
            "type": "method"
          },
          {
            "name": "src",
            "optional": false,
            "type": "(m: M) => O; // domain of m"
          },
          {
            "name": "src",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "SNFCertificate",
      "type": "type",
      "file": "src/types/snf-witness.ts",
      "line": 14,
      "definition": "{\n  U: Mat",
      "shape": {
        "type": "primitive",
        "definition": "{\n  U: Mat"
      }
    },
    {
      "name": "SNFVerificationWitness",
      "type": "interface",
      "file": "src/types/snf-surface-api.ts",
      "line": 13,
      "properties": [
        {
          "name": "loc",
          "optional": false,
          "type": "[number, number];  // Position [i,j] where mismatch occurs"
        },
        {
          "name": "got",
          "optional": false,
          "type": "number;           // Actual value at U*A*V[i][j]"
        },
        {
          "name": "expected",
          "optional": false,
          "type": "number;      // Expected value at D[i][j]"
        },
        {
          "name": "matrixSizes",
          "optional": false,
          "type": "{"
        },
        {
          "name": "U",
          "optional": false,
          "type": "[number, number]"
        },
        {
          "name": "A",
          "optional": false,
          "type": "[number, number]"
        },
        {
          "name": "V",
          "optional": false,
          "type": "[number, number]"
        },
        {
          "name": "D",
          "optional": false,
          "type": "[number, number]"
        }
      ],
      "shape": {
        "propertyCount": 8,
        "properties": [
          {
            "name": "A",
            "optional": false,
            "type": "[number, number]"
          },
          {
            "name": "D",
            "optional": false,
            "type": "[number, number]"
          },
          {
            "name": "expected",
            "optional": false,
            "type": "number; // Expected value at D[i][j]"
          },
          {
            "name": "got",
            "optional": false,
            "type": "number; // Actual value at U*A*V[i][j]"
          },
          {
            "name": "loc",
            "optional": false,
            "type": "[number, number]; // Position [i,j] where mismatch occurs"
          },
          {
            "name": "matrixSizes",
            "optional": false,
            "type": "{"
          },
          {
            "name": "U",
            "optional": false,
            "type": "[number, number]"
          },
          {
            "name": "V",
            "optional": false,
            "type": "[number, number]"
          }
        ]
      }
    },
    {
      "name": "SNFWitness",
      "type": "type",
      "file": "src/types/snf-witness.ts",
      "line": 10,
      "definition": "| { ok: true }\n  | { ok: false",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "ok",
            "optional": false,
            "type": "true"
          }
        ]
      }
    },
    {
      "name": "SourceRef",
      "type": "type",
      "file": "src/types/math-trace-types.ts",
      "line": 5,
      "definition": "| { type: \"slide\"",
      "shape": {
        "type": "primitive",
        "definition": "| { type: \"slide\""
      }
    },
    {
      "name": "Square",
      "type": "type",
      "file": "src/types/double-lax-functor.ts",
      "line": 8,
      "definition": "{\n  A: Finite<A>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  A: Finite<A>"
      }
    },
    {
      "name": "SquareResult",
      "type": "type",
      "file": "src/universal/monad/Diagram.ts",
      "line": 13,
      "definition": "{\n  commutes: boolean",
      "shape": {
        "type": "primitive",
        "definition": "{\n  commutes: boolean"
      }
    },
    {
      "name": "SquareWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 43,
      "definition": "{\n  commutes: boolean",
      "shape": {
        "type": "primitive",
        "definition": "{\n  commutes: boolean"
      }
    },
    {
      "name": "SSet02",
      "type": "type",
      "file": "src/types/catkit-homology.ts",
      "line": 631,
      "definition": "{\n  V: string[]",
      "shape": {
        "type": "primitive",
        "definition": "{\n  V: string[]"
      }
    },
    {
      "name": "SSetUpTo3",
      "type": "type",
      "file": "src/types/sset-quasicat.ts",
      "line": 28,
      "definition": "{\n  V: Obj[]",
      "shape": {
        "type": "primitive",
        "definition": "{\n  V: Obj[]"
      }
    },
    {
      "name": "Star",
      "type": "type",
      "file": "src/types/catkit-traversal.ts",
      "line": 63,
      "definition": "(a:A) => any",
      "shape": {
        "type": "function",
        "signature": "(a:A) => any"
      }
    },
    {
      "name": "State",
      "type": "type",
      "file": "src/types/strong-monad.ts",
      "line": 94,
      "definition": "(s: S) => [A, S]",
      "shape": {
        "type": "function",
        "signature": "(s: S) => [A, S]"
      }
    },
    {
      "name": "Stoch",
      "type": "type",
      "file": "src/prob/Markov.ts",
      "line": 4,
      "definition": "number[][]",
      "shape": {
        "type": "primitive",
        "definition": "number[][]"
      }
    },
    {
      "name": "StrengthUnitWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 110,
      "definition": "{\n  a: any",
      "shape": {
        "type": "primitive",
        "definition": "{\n  a: any"
      }
    },
    {
      "name": "StringDiagram",
      "type": "interface",
      "file": "src/types/double-lax-functor.ts",
      "line": 98,
      "properties": [
        {
          "name": "nodes",
          "optional": false,
          "type": "Array<{id: string; type: 'input' | 'output' | 'operation'"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "nodes",
            "optional": false,
            "type": "Array<{id: string; type: 'input' | 'output' | 'operation'"
          }
        ]
      }
    },
    {
      "name": "StrongMonad",
      "type": "interface",
      "file": "src/types/strong-monad.ts",
      "line": 20,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "StrongMonadLawResults",
      "type": "type",
      "file": "src/types/strong-monad.ts",
      "line": 203,
      "definition": "{\n  monadLaws: {\n    leftUnit: LawCheck<MonadLeftUnitWitness<T>>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  monadLaws: {\n    leftUnit: LawCheck<MonadLeftUnitWitness<T>>"
      }
    },
    {
      "name": "StrongMonadWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 71,
      "definition": "{\n  monadLaws: MonadLawWitness<T>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  monadLaws: MonadLawWitness<T>"
      }
    },
    {
      "name": "Subgroup",
      "type": "interface",
      "file": "src/algebra/group/NormalSubgroup.ts",
      "line": 7,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "Sum",
      "type": "type",
      "file": "src/types/adt-sum-prod.ts",
      "line": 5,
      "definition": "Inl<A> | Inr<B>",
      "shape": {
        "type": "primitive",
        "definition": "Inl<A> | Inr<B>"
      }
    },
    {
      "name": "Surj",
      "type": "type",
      "file": "src/types/spec-impl.ts",
      "line": 15,
      "definition": "{ p: Fun<A,Â>",
      "shape": {
        "type": "primitive",
        "definition": "{ p: Fun<A,Â>"
      }
    },
    {
      "name": "Surjection",
      "type": "type",
      "file": "src/types/surjection-types.ts",
      "line": 10,
      "definition": "{\n  readonly [SurjBrand]: \"Surjection\"",
      "shape": {
        "type": "primitive",
        "definition": "{\n  readonly [SurjBrand]: \"Surjection\""
      }
    },
    {
      "name": "SurjectionWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 30,
      "definition": "{ \n  p: (a: A) => Â",
      "shape": {
        "type": "function",
        "signature": "{ \n  p: (a: A) => Â"
      }
    },
    {
      "name": "Suspend",
      "type": "interface",
      "file": "src/types/advanced.ts",
      "line": 321,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "Tagged",
      "type": "type",
      "file": "src/types/catkit-prisms.ts",
      "line": 68,
      "definition": "{ value: B }",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "value",
            "optional": false,
            "type": "B"
          }
        ]
      }
    },
    {
      "name": "TCarrier",
      "type": "interface",
      "file": "src/universal/monad/LawvereMonad.ts",
      "line": 21,
      "properties": [
        {
          "name": "elems",
          "optional": false,
          "type": "Term[]"
        },
        {
          "name": "eq",
          "optional": false,
          "type": "(t1: Term, t2: Term) => boolean"
        },
        {
          "name": "eq",
          "optional": false,
          "type": "method",
          "signature": "(t1: Term, t2: Term)",
          "returnType": "boolean"
        }
      ],
      "shape": {
        "propertyCount": 3,
        "properties": [
          {
            "name": "elems",
            "optional": false,
            "type": "Term[]"
          },
          {
            "name": "eq",
            "optional": false,
            "type": "(t1: Term, t2: Term) => boolean"
          },
          {
            "name": "eq",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "Term",
      "type": "type",
      "file": "src/universal/Term.ts",
      "line": 6,
      "definition": "Var | App",
      "shape": {
        "type": "primitive",
        "definition": "Var | App"
      }
    },
    {
      "name": "TermF",
      "type": "type",
      "file": "src/gadt/examples/Term.ts",
      "line": 5,
      "definition": "| { _t:\"const\"",
      "shape": {
        "type": "primitive",
        "definition": "| { _t:\"const\""
      }
    },
    {
      "name": "Tet",
      "type": "type",
      "file": "src/types/sset-quasicat.ts",
      "line": 22,
      "definition": "{\n  key:string",
      "shape": {
        "type": "primitive",
        "definition": "{\n  key:string"
      }
    },
    {
      "name": "ThinMor",
      "type": "type",
      "file": "src/types/catkit-posets.ts",
      "line": 22,
      "definition": "{\n  readonly src: T",
      "shape": {
        "type": "primitive",
        "definition": "{\n  readonly src: T"
      }
    },
    {
      "name": "ThirdIsoResult",
      "type": "interface",
      "file": "src/algebra/group/ThirdIso.ts",
      "line": 8,
      "properties": [
        {
          "name": "Q_GmodK",
          "optional": false,
          "type": "Group<Coset<A>>;          // G/K"
        },
        {
          "name": "NmodK_in_Q",
          "optional": false,
          "type": "Subgroup<Coset<A>>;    // N/K ≤ G/K"
        },
        {
          "name": "Q_over_NmodK",
          "optional": false,
          "type": "Group<any>;          // (G/K)/(N/K)"
        },
        {
          "name": "GmodN",
          "optional": false,
          "type": "Group<Coset<A>>;            // G/N"
        },
        {
          "name": "iso",
          "optional": false,
          "type": "GroupIso<any, any>"
        }
      ],
      "shape": {
        "propertyCount": 5,
        "properties": [
          {
            "name": "GmodN",
            "optional": false,
            "type": "Group<T>>; // G/N"
          },
          {
            "name": "iso",
            "optional": false,
            "type": "GroupIso<T>"
          },
          {
            "name": "NmodK_in_Q",
            "optional": false,
            "type": "Subgroup<T>>; // N/K ≤ G/K"
          },
          {
            "name": "Q_GmodK",
            "optional": false,
            "type": "Group<T>>; // G/K"
          },
          {
            "name": "Q_over_NmodK",
            "optional": false,
            "type": "Group<T>; // (G/K)/(N/K)"
          }
        ]
      }
    },
    {
      "name": "Top",
      "type": "type",
      "file": "src/top/Topology.ts",
      "line": 2,
      "definition": "{\n  carrier: X[]",
      "shape": {
        "type": "primitive",
        "definition": "{\n  carrier: X[]"
      }
    },
    {
      "name": "Topology",
      "type": "interface",
      "file": "src/types/topology.ts",
      "line": 32,
      "properties": [
        {
          "name": "carrier",
          "optional": false,
          "type": "FS<A>"
        },
        {
          "name": "opens",
          "optional": false,
          "type": "Set<string>"
        },
        {
          "name": "isOpen",
          "optional": false,
          "type": "(S: Set<A>) => boolean"
        },
        {
          "name": "isOpen",
          "optional": false,
          "type": "method",
          "signature": "(S: Set<A>)",
          "returnType": "boolean"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "carrier",
            "optional": false,
            "type": "FS<T>"
          },
          {
            "name": "isOpen",
            "optional": false,
            "type": "(S: Set<T>) => boolean"
          },
          {
            "name": "isOpen",
            "optional": false,
            "type": "method"
          },
          {
            "name": "opens",
            "optional": false,
            "type": "Set<T>"
          }
        ]
      }
    },
    {
      "name": "TraceReport",
      "type": "interface",
      "file": "src/types/math-trace-types.ts",
      "line": 33,
      "properties": [
        {
          "name": "totalTags",
          "optional": false,
          "type": "number"
        },
        {
          "name": "validTagCount",
          "optional": false,
          "type": "number"
        },
        {
          "name": "missingTags",
          "optional": false,
          "type": "FoundTag[]"
        },
        {
          "name": "validTags",
          "optional": false,
          "type": "FoundTag[]"
        },
        {
          "name": "registrySize",
          "optional": false,
          "type": "number"
        },
        {
          "name": "coverage",
          "optional": false,
          "type": "{"
        },
        {
          "name": "filesWithTags",
          "optional": false,
          "type": "number"
        },
        {
          "name": "totalFiles",
          "optional": false,
          "type": "number"
        },
        {
          "name": "percentage",
          "optional": false,
          "type": "number"
        }
      ],
      "shape": {
        "propertyCount": 9,
        "properties": [
          {
            "name": "coverage",
            "optional": false,
            "type": "{"
          },
          {
            "name": "filesWithTags",
            "optional": false,
            "type": "number"
          },
          {
            "name": "missingTags",
            "optional": false,
            "type": "FoundTag[]"
          },
          {
            "name": "percentage",
            "optional": false,
            "type": "number"
          },
          {
            "name": "registrySize",
            "optional": false,
            "type": "number"
          },
          {
            "name": "totalFiles",
            "optional": false,
            "type": "number"
          },
          {
            "name": "totalTags",
            "optional": false,
            "type": "number"
          },
          {
            "name": "validTagCount",
            "optional": false,
            "type": "number"
          },
          {
            "name": "validTags",
            "optional": false,
            "type": "FoundTag[]"
          }
        ]
      }
    },
    {
      "name": "TransformerAdjunctionWitness",
      "type": "type",
      "file": "src/types/witnesses.ts",
      "line": 151,
      "definition": "{\n  P: any",
      "shape": {
        "type": "primitive",
        "definition": "{\n  P: any"
      }
    },
    {
      "name": "Traversal",
      "type": "type",
      "file": "src/types/optics-witness.ts",
      "line": 135,
      "definition": "{\n  modify: (s:S, k:(a:A)=>A)=> S",
      "shape": {
        "type": "function",
        "signature": "{\n  modify: (s:S, k:(a:A)=>A)=> S"
      }
    },
    {
      "name": "TraversalWitness",
      "type": "type",
      "file": "src/types/optics-witness.ts",
      "line": 139,
      "definition": "{\n  identity: { ok:true } | { ok:false",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "identity",
            "optional": false,
            "type": "{ ok:true"
          }
        ]
      }
    },
    {
      "name": "Tri",
      "type": "type",
      "file": "src/types/sset-quasicat.ts",
      "line": 16,
      "definition": "{\n  key:string",
      "shape": {
        "type": "primitive",
        "definition": "{\n  key:string"
      }
    },
    {
      "name": "TriangleResult",
      "type": "type",
      "file": "src/universal/monad/Diagram.ts",
      "line": 8,
      "definition": "{\n  commutes: boolean",
      "shape": {
        "type": "primitive",
        "definition": "{\n  commutes: boolean"
      }
    },
    {
      "name": "Trifunctor",
      "type": "interface",
      "file": "src/types/functors.ts",
      "line": 30,
      "properties": [
        {
          "name": "trimap",
          "optional": false,
          "type": "<R, E, A, R2, E2, A2>("
        },
        {
          "name": "r",
          "optional": false,
          "type": "HKT3<F, R, E, A>, fR: (r: R2) => R, fE: (e: E) => E2, fA: (a: A) => A2"
        }
      ],
      "shape": {
        "propertyCount": 2,
        "properties": [
          {
            "name": "r",
            "optional": false,
            "type": "HKT3<T>, fR: (r: R2) => R, fE: (e: E) => E2, fA: (a: A) => A2"
          },
          {
            "name": "trimap",
            "optional": false,
            "type": "<R, E, A, R2, E2, A2>("
          }
        ]
      }
    },
    {
      "name": "TripleKind",
      "type": "type",
      "file": "src/types/allegory-witness.ts",
      "line": 70,
      "definition": "\"demonic\" | \"angelic\"",
      "shape": {
        "type": "primitive",
        "definition": "\"demonic\" | \"angelic\""
      }
    },
    {
      "name": "TwoCategory",
      "type": "interface",
      "file": "src/types/two-category.ts",
      "line": 11,
      "properties": [
        {
          "name": "id1",
          "optional": false,
          "type": "(A: Obj) => One"
        },
        {
          "name": "id1",
          "optional": false,
          "type": "method",
          "signature": "(A: Obj)",
          "returnType": "One"
        },
        {
          "name": "comp1",
          "optional": false,
          "type": "(g: One, f: One) => One"
        },
        {
          "name": "comp1",
          "optional": false,
          "type": "method",
          "signature": "(g: One, f: One)",
          "returnType": "One"
        },
        {
          "name": "id2",
          "optional": false,
          "type": "(f: One) => Two"
        },
        {
          "name": "id2",
          "optional": false,
          "type": "method",
          "signature": "(f: One)",
          "returnType": "Two"
        },
        {
          "name": "vcomp",
          "optional": false,
          "type": "(beta: Two, alpha: Two) => Two"
        },
        {
          "name": "vcomp",
          "optional": false,
          "type": "method",
          "signature": "(beta: Two, alpha: Two)",
          "returnType": "Two"
        },
        {
          "name": "hcomp",
          "optional": false,
          "type": "(beta: Two, alpha: Two) => Two"
        },
        {
          "name": "hcomp",
          "optional": false,
          "type": "method",
          "signature": "(beta: Two, alpha: Two)",
          "returnType": "Two"
        },
        {
          "name": "whiskerL",
          "optional": false,
          "type": "(F: One, alpha: Two) => Two"
        },
        {
          "name": "whiskerL",
          "optional": false,
          "type": "method",
          "signature": "(F: One, alpha: Two)",
          "returnType": "Two"
        },
        {
          "name": "whiskerR",
          "optional": false,
          "type": "(alpha: Two, G: One) => Two"
        },
        {
          "name": "whiskerR",
          "optional": false,
          "type": "method",
          "signature": "(alpha: Two, G: One)",
          "returnType": "Two"
        },
        {
          "name": "eq2",
          "optional": true,
          "type": "(x: Two, y: Two) => boolean"
        },
        {
          "name": "eq2",
          "optional": true,
          "type": "method",
          "signature": "(x: Two, y: Two)",
          "returnType": "boolean"
        }
      ],
      "shape": {
        "propertyCount": 16,
        "properties": [
          {
            "name": "comp1",
            "optional": false,
            "type": "(g: One, f: One) => One"
          },
          {
            "name": "comp1",
            "optional": false,
            "type": "method"
          },
          {
            "name": "eq2",
            "optional": true,
            "type": "(x: Two, y: Two) => boolean"
          },
          {
            "name": "eq2",
            "optional": true,
            "type": "method"
          },
          {
            "name": "hcomp",
            "optional": false,
            "type": "(beta: Two, alpha: Two) => Two"
          },
          {
            "name": "hcomp",
            "optional": false,
            "type": "method"
          },
          {
            "name": "id1",
            "optional": false,
            "type": "(A: Obj) => One"
          },
          {
            "name": "id1",
            "optional": false,
            "type": "method"
          },
          {
            "name": "id2",
            "optional": false,
            "type": "(f: One) => Two"
          },
          {
            "name": "id2",
            "optional": false,
            "type": "method"
          },
          {
            "name": "vcomp",
            "optional": false,
            "type": "(beta: Two, alpha: Two) => Two"
          },
          {
            "name": "vcomp",
            "optional": false,
            "type": "method"
          },
          {
            "name": "whiskerL",
            "optional": false,
            "type": "(F: One, alpha: Two) => Two"
          },
          {
            "name": "whiskerL",
            "optional": false,
            "type": "method"
          },
          {
            "name": "whiskerR",
            "optional": false,
            "type": "(alpha: Two, G: One) => Two"
          },
          {
            "name": "whiskerR",
            "optional": false,
            "type": "method"
          }
        ]
      }
    },
    {
      "name": "TwoElt",
      "type": "type",
      "file": "src/algebra/group/FiniteGroups.ts",
      "line": 14,
      "definition": "\"e\" | \"j\"",
      "shape": {
        "type": "primitive",
        "definition": "\"e\" | \"j\""
      }
    },
    {
      "name": "Ty",
      "type": "type",
      "file": "src/types/gadt-expr.ts",
      "line": 5,
      "definition": "| { tag: \"number\" }\n  | { tag: \"boolean\" }\n  | { tag: \"pair\"",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "tag",
            "optional": false,
            "type": "\"number\""
          }
        ]
      }
    },
    {
      "name": "UAAlgebra",
      "type": "type",
      "file": "src/universal/Algebra.ts",
      "line": 5,
      "definition": "{\n  sig: Signature",
      "shape": {
        "type": "primitive",
        "definition": "{\n  sig: Signature"
      }
    },
    {
      "name": "UAHom",
      "type": "type",
      "file": "src/universal/Hom.ts",
      "line": 5,
      "definition": "{\n  source: UAAlgebra<A>",
      "shape": {
        "type": "primitive",
        "definition": "{\n  source: UAAlgebra<A>"
      }
    },
    {
      "name": "Ultrafilter",
      "type": "interface",
      "file": "src/types/ultrafilter.ts",
      "line": 13,
      "properties": [
        {
          "name": "contains",
          "optional": false,
          "type": "(S: FiniteSubset<A>) => boolean"
        },
        {
          "name": "contains",
          "optional": false,
          "type": "method",
          "signature": "(S: FiniteSubset<A>)",
          "returnType": "boolean"
        },
        {
          "name": "isPrincipal",
          "optional": false,
          "type": "boolean"
        },
        {
          "name": "principalWitness",
          "optional": true,
          "type": "A"
        }
      ],
      "shape": {
        "propertyCount": 4,
        "properties": [
          {
            "name": "contains",
            "optional": false,
            "type": "(S: FiniteSubset<T>) => boolean"
          },
          {
            "name": "contains",
            "optional": false,
            "type": "method"
          },
          {
            "name": "isPrincipal",
            "optional": false,
            "type": "boolean"
          },
          {
            "name": "principalWitness",
            "optional": true,
            "type": "A"
          }
        ]
      }
    },
    {
      "name": "Unfoldable",
      "type": "interface",
      "file": "src/types/foldable.ts",
      "line": 15,
      "properties": [
        {
          "name": "unfold",
          "optional": false,
          "type": "<A, B>(b: B, f: (b: B) => [A, B] | null) => HKT<F, A>"
        }
      ],
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "unfold",
            "optional": false,
            "type": "<A, B>(b: B, f: (b: B) => [A, B] | null) => HKT<T>"
          }
        ]
      }
    },
    {
      "name": "Unit",
      "type": "type",
      "file": "src/types/adt-sum-prod.ts",
      "line": 13,
      "definition": "{ _t: \"unit\" }",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "_t",
            "optional": false,
            "type": "\"unit\""
          }
        ]
      }
    },
    {
      "name": "URI_ExprF",
      "type": "type",
      "file": "src/types/optics-free.ts",
      "line": 217,
      "definition": "typeof URI_ExprF",
      "shape": {
        "type": "primitive",
        "definition": "typeof URI_ExprF"
      }
    },
    {
      "name": "URI_IdFree",
      "type": "type",
      "file": "src/types/optics-free.ts",
      "line": 155,
      "definition": "typeof URI_IdFree",
      "shape": {
        "type": "primitive",
        "definition": "typeof URI_IdFree"
      }
    },
    {
      "name": "URIS",
      "type": "type",
      "file": "src/types/hkt.ts",
      "line": 4,
      "definition": "keyof URItoKind<unknown>",
      "shape": {
        "type": "primitive",
        "definition": "keyof URItoKind<unknown>"
      }
    },
    {
      "name": "URIS2",
      "type": "type",
      "file": "src/types/hkt.ts",
      "line": 10,
      "definition": "keyof URItoKind2<unknown, unknown>",
      "shape": {
        "type": "primitive",
        "definition": "keyof URItoKind2<unknown, unknown>"
      }
    },
    {
      "name": "URIS2Free",
      "type": "type",
      "file": "src/types/optics-free.ts",
      "line": 16,
      "definition": "keyof URItoKind2Free<any, any>",
      "shape": {
        "type": "primitive",
        "definition": "keyof URItoKind2Free<any, any>"
      }
    },
    {
      "name": "URIS3",
      "type": "type",
      "file": "src/types/hkt.ts",
      "line": 14,
      "definition": "keyof URItoKind3<unknown, unknown, unknown>",
      "shape": {
        "type": "primitive",
        "definition": "keyof URItoKind3<unknown, unknown, unknown>"
      }
    },
    {
      "name": "URIS3Free",
      "type": "type",
      "file": "src/types/optics-free.ts",
      "line": 17,
      "definition": "keyof URItoKind3Free<any, any, any>",
      "shape": {
        "type": "primitive",
        "definition": "keyof URItoKind3Free<any, any, any>"
      }
    },
    {
      "name": "URISFree",
      "type": "type",
      "file": "src/types/optics-free.ts",
      "line": 15,
      "definition": "keyof URItoKindFree<any>",
      "shape": {
        "type": "primitive",
        "definition": "keyof URItoKindFree<any>"
      }
    },
    {
      "name": "URISProf",
      "type": "type",
      "file": "src/types/hkt.ts",
      "line": 24,
      "definition": "keyof URItoKindProf<unknown, unknown>",
      "shape": {
        "type": "primitive",
        "definition": "keyof URItoKindProf<unknown, unknown>"
      }
    },
    {
      "name": "URItoKind2Free",
      "type": "interface",
      "file": "src/types/optics-free.ts",
      "line": 8,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "URItoKind3Free",
      "type": "interface",
      "file": "src/types/optics-free.ts",
      "line": 11,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "URItoKindFree",
      "type": "interface",
      "file": "src/types/optics-free.ts",
      "line": 5,
      "properties": [],
      "shape": {
        "propertyCount": 0,
        "properties": []
      }
    },
    {
      "name": "Validation",
      "type": "type",
      "file": "src/types/freeapp-coyo.ts",
      "line": 84,
      "definition": "| { ok: true",
      "shape": {
        "type": "primitive",
        "definition": "| { ok: true"
      }
    },
    {
      "name": "Var",
      "type": "type",
      "file": "src/universal/Term.ts",
      "line": 4,
      "definition": "{ tag: \"Var\"",
      "shape": {
        "type": "primitive",
        "definition": "{ tag: \"Var\""
      }
    },
    {
      "name": "Vec",
      "type": "type",
      "file": "src/types/finvect.ts",
      "line": 4,
      "definition": "Bit[]",
      "shape": {
        "type": "primitive",
        "definition": "Bit[]"
      }
    },
    {
      "name": "VecF",
      "type": "type",
      "file": "src/gadt/basic/Vec.ts",
      "line": 19,
      "definition": "| { _t:\"vnil\"",
      "shape": {
        "type": "primitive",
        "definition": "| { _t:\"vnil\""
      }
    },
    {
      "name": "Vertex",
      "type": "type",
      "file": "src/types/quiver-pushout.ts",
      "line": 13,
      "definition": "string",
      "shape": {
        "type": "primitive",
        "definition": "string"
      }
    },
    {
      "name": "Void",
      "type": "type",
      "file": "src/types/adt-sum-prod.ts",
      "line": 15,
      "definition": "never",
      "shape": {
        "type": "primitive",
        "definition": "never"
      }
    },
    {
      "name": "WanderDict",
      "type": "interface",
      "file": "src/types/catkit-traversal.ts",
      "line": 65,
      "properties": [
        {
          "name": "dimap",
          "optional": false,
          "type": "<A,B,C,D>(p: any, l:(c:C)=>A, r:(b:B)=>D)=> any"
        },
        {
          "name": "first",
          "optional": false,
          "type": "<A,B,C>(p: any)=> any"
        },
        {
          "name": "left",
          "optional": false,
          "type": "<A,B,C>(p: any)=> any"
        },
        {
          "name": "right",
          "optional": false,
          "type": "<A,B,C>(p: any)=> any"
        },
        {
          "name": "wander",
          "optional": false,
          "type": "<A,B,S,T>("
        },
        {
          "name": "walk",
          "optional": false,
          "type": "<F>(F: Applicative<F, any>) => (ab: (a:A)=>any) => (s:S)=> any"
        },
        {
          "name": "pab",
          "optional": false,
          "type": "any"
        }
      ],
      "shape": {
        "propertyCount": 7,
        "properties": [
          {
            "name": "dimap",
            "optional": false,
            "type": "<A,B,C,D>(p: any, l:(c:C)=>A, r:(b:B)=>D)=> any"
          },
          {
            "name": "first",
            "optional": false,
            "type": "<A,B,C>(p: any)=> any"
          },
          {
            "name": "left",
            "optional": false,
            "type": "<A,B,C>(p: any)=> any"
          },
          {
            "name": "pab",
            "optional": false,
            "type": "any"
          },
          {
            "name": "right",
            "optional": false,
            "type": "<A,B,C>(p: any)=> any"
          },
          {
            "name": "walk",
            "optional": false,
            "type": "<F>(F: Applicative<T>) => (ab: (a:A)=>any) => (s:S)=> any"
          },
          {
            "name": "wander",
            "optional": false,
            "type": "<A,B,S,T>("
          }
        ]
      }
    },
    {
      "name": "WithWitnesses",
      "type": "type",
      "file": "src/algebra/group/WitnessGuard.ts",
      "line": 3,
      "definition": "F extends GroupHom<infer A, infer B> ? GroupHom<A,B> & { witnesses: HomWitnesses<A,B> } : never",
      "shape": {
        "propertyCount": 1,
        "properties": [
          {
            "name": "witnesses",
            "optional": false,
            "type": "HomWitnesses<T>"
          }
        ]
      }
    },
    {
      "name": "WitnessLevel",
      "type": "type",
      "file": "src/types/config.ts",
      "line": 11,
      "definition": "'minimal' | 'detailed' | 'verbose'",
      "shape": {
        "type": "primitive",
        "definition": "'minimal' | 'detailed' | 'verbose'"
      }
    },
    {
      "name": "WitnessPredicate",
      "type": "type",
      "file": "src/types/property-shrinking.ts",
      "line": 8,
      "definition": "(witness: T) => boolean",
      "shape": {
        "type": "function",
        "signature": "(witness: T) => boolean"
      }
    },
    {
      "name": "Word",
      "type": "type",
      "file": "src/algebra/semiringlike/free/FreeMonoid.ts",
      "line": 6,
      "definition": "A[]",
      "shape": {
        "type": "primitive",
        "definition": "A[]"
      }
    },
    {
      "name": "Writer",
      "type": "type",
      "file": "src/types/strong-monad.ts",
      "line": 116,
      "definition": "[A, W]",
      "shape": {
        "type": "primitive",
        "definition": "[A, W]"
      }
    }
  ]
}