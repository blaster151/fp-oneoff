import type { Signature } from "../Signature";
import { Var, App, type Term, subst as substVars } from "../Term";
import { enumerateTerms, congruenceClosure } from "../Congruence";

/**
 * Lawvere theory L for a finitary algebraic theory (sig, equations).
 * Objects are natural numbers (n ≅ 1^n). A morphism n→m is an m-tuple of terms in variables {0..n-1},
 * modulo the congruence generated by equations E (closed under substitution).
 * We build only the finite-depth approximation using `maxDepth`.
 */
export type Lawvere = {
  sig: Signature;
  maxDepth: number;
  // Reduce a term under ≡_E with variables bounded by n
  reduce: (n: number, t: Term) => Term;
  // Identity at n: <x0,...,x_{n-1}>
  id: (n: number) => Term[];
  // Compose s: n→m with r: k→n to get k→m (substitute & reduce)
  compose: (s: Term[], r: Term[]) => Term[];
};

/** Build a Lawvere theory object from a signature and a finite set of equations (lhs≈rhs). */
export function buildLawvere(sig: Signature, equations: Array<{lhs:Term; rhs:Term}>, maxDepth=2): Lawvere {
  // cache congruences per arity n
  const cache = new Map<number, { reduce:(t:Term)=>Term }>();

  function reducer(n: number) {
    if (cache.has(n)) return cache.get(n)!;
    const T = enumerateTerms(sig, n, maxDepth);
    const { reprOf } = congruenceClosure(sig, T, equations);
    const reduce = (t: Term) => reprOf(t);
    const entry = { reduce }; cache.set(n, entry); return entry;
  }

  const reduce = (n: number, t: Term) => reducer(n).reduce(t);
  const id = (n: number) => Array.from({length:n}, (_,i)=> Var(i));
  const compose = (s: Term[], r: Term[]) => {
    // s : n→m (m terms over vars 0..n-1); r : k→n (n terms over vars 0..k-1)
    // result : k→m  given by t_i[r/x] then reduce in arity k
    const n = r.length;
    const k = distinctVarUpperBound(r);
    const out: Term[] = [];
    for (const t of s) {
      const tr = substTupleByVars(t, r);
      const reduced = reducer(k).reduce(tr);
      if (reduced) {
        out.push(reduced);
      } else {
        // Fallback: use the substituted term if reduction fails
        out.push(tr);
      }
    }
    return out;
  };

  return { sig, maxDepth, reduce, id, compose };
}

/** Substitute variables by a tuple r: for Var(i) use r[i] if present, else keep Var(i). */
function substTupleByVars(t: Term, r: Term[]): Term {
  return (function go(u: Term): Term {
    if ((u as any).tag==="Var") {
      const i = (u as any).ix;
      return (i<r.length && r[i]!==undefined) ? r[i] : u;
    }
    const { op, args } = u as any;
    return App(op, (args as Term[]).map(go));
  })(t);
}

function distinctVarUpperBound(ts: Term[]): number {
  let mx = -1;
  const bump = (t: Term) => {
    if ((t as any).tag==="Var") { if ((t as any).ix > mx) mx = (t as any).ix; return; }
    for (const u of (t as any).args as Term[]) bump(u);
  };
  for (const t of ts) bump(t);
  return mx+1;
}