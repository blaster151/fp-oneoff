// ultrafilter.ts
// Ultrafilter construction from Codensity monads
// Uses the Boolean component of T^G(A) to define ultrafilters via characteristic functions

import { mkCodensityMonad } from "./codensity-monad.js";
import { MiniFinSet, G_inclusion, asSetObj } from "./mini-finset.js";
import { SetObj } from "./catkit-kan.js";

/************ Ultrafilter Types ************/

export type FiniteSubset<A> = Set<A>;

export interface Ultrafilter<A> {
  contains: (S: FiniteSubset<A>) => boolean;
  isPrincipal: boolean;
  principalWitness?: A;
}

/************ Core Ultrafilter Construction ************/

/**
 * Build ultrafilter from Codensity element
 * 
 * Given t ‚àà T^G(A), interpret as ultrafilter on A using the Bool component:
 * U(S) := (t)_2(œá_S) == true
 * where œá_S : A ‚Üí 2 is the characteristic function of S
 */
export function ultrafilterFromCodensity<A>(
  Aset: SetObj<A>,
  t: any
): Ultrafilter<A> {
  
  const contains = (S: Set<A>): boolean => {
    // Extract component at object "2" (Bool)
    if (t && typeof t === 'object' && t.at) {
      const phi2 = t.at("2");
      
      if (typeof phi2 === 'function') {
        // Create characteristic function œá_S : A ‚Üí Bool
        const chi = (a: A) => S.has(a);
        
        // Apply the component: œÜ_2(œá_S)
        const result = phi2(chi);
        return result === true;
      }
    }
    
    // Fallback: check if subset contains the principal witness
    if (t && t.principalWitness !== undefined) {
      return S.has(t.principalWitness);
    }
    
    return false;
  };

  // For finite A, every ultrafilter is principal
  // Find the unique a with {a} ‚àà U
  let witness: A | undefined = undefined;
  
  for (const a of Aset.elems) {
    const singleton = new Set<A>([a]);
    if (contains(singleton)) {
      witness = a;
      break;
    }
  }

  return {
    contains,
    isPrincipal: witness !== undefined,
    principalWitness: witness!
  } as Ultrafilter<A>;
}

/**
 * Principal ultrafilter generated by a ‚àà A (for comparison in tests)
 */
export function principalUltrafilter<A>(
  Aset: SetObj<A>,
  a: A
): Ultrafilter<A> {
  const contains = (S: Set<A>) => S.has(a);
  
  return { 
    contains, 
    isPrincipal: true, 
    principalWitness: a 
  };
}

/************ Subset Operations ************/

/** Create subset from array */
export const subset = <A>(xs: A[]) => new Set<A>(xs);

/** Intersection of two sets */
export const inter = <A>(X: Set<A>, Y: Set<A>) =>
  new Set<A>([...X].filter(x => Y.has(x)));

/** Union of two sets */
export const union = <A>(X: Set<A>, Y: Set<A>) =>
  new Set<A>([...X, ...Y]);

/** Complement relative to universe */
export const compl = <A>(Aset: SetObj<A>, X: Set<A>) =>
  new Set<A>(Aset.elems.filter(a => !X.has(a)));

/** Check if X ‚äÜ Y */
export const isSubset = <A>(X: Set<A>, Y: Set<A>): boolean =>
  [...X].every(x => Y.has(x));

/** Check if X = Y */
export const setEqual = <A>(X: Set<A>, Y: Set<A>): boolean =>
  X.size === Y.size && isSubset(X, Y);

/************ Ultrafilter Properties Verification ************/

/**
 * Verify ultrafilter laws for a given ultrafilter
 */
export function verifyUltrafilterLaws<A>(
  Aset: SetObj<A>,
  U: Ultrafilter<A>
): { valid: boolean; violations: string[] } {
  const violations: string[] = [];
  
  // Generate test subsets
  const testSubsets = allSubsets(Aset).slice(0, 8); // Limit for performance
  
  // Law 1: Upward closure - if S ‚äÜ T and U(S), then U(T)
  for (let i = 0; i < testSubsets.length; i++) {
    for (let j = 0; j < testSubsets.length; j++) {
      const S = testSubsets[i]!;
      const T = testSubsets[j]!;
      
      if (isSubset(S, T) && U.contains(S) && !U.contains(T)) {
        violations.push(`Upward closure: ${setToString(S)} ‚äÜ ${setToString(T)} but U(S) ‚àß ¬¨U(T)`);
      }
    }
  }
  
  // Law 2: Proper filter - doesn't contain empty set, contains universe
  const empty = new Set<A>();
  const universe = new Set<A>(Aset.elems);
  
  if (U.contains(empty)) {
    violations.push("Contains empty set (not proper)");
  }
  
  if (!U.contains(universe)) {
    violations.push("Doesn't contain universe");
  }
  
  // Law 3: Closed under finite intersection
  for (let i = 0; i < Math.min(testSubsets.length, 4); i++) {
    for (let j = 0; j < Math.min(testSubsets.length, 4); j++) {
      const S = testSubsets[i]!;
      const T = testSubsets[j]!;
      const intersection = inter(S, T);
      
      const containsS = U.contains(S);
      const containsT = U.contains(T);
      const containsIntersection = U.contains(intersection);
      
      if (containsS && containsT && !containsIntersection) {
        violations.push(`Intersection: U(${setToString(S)}) ‚àß U(${setToString(T)}) but ¬¨U(${setToString(intersection)})`);
      }
    }
  }
  
  // Law 4: Prime property - for each set S, either U(S) or U(complement(S))
  for (const S of testSubsets.slice(0, 4)) {
    const complement = compl(Aset, S);
    const containsS = U.contains(S);
    const containsComplement = U.contains(complement);
    
    if (!containsS && !containsComplement) {
      violations.push(`Prime: neither U(${setToString(S)}) nor U(${setToString(complement)})`);
    }
    
    if (containsS && containsComplement) {
      violations.push(`Prime: both U(${setToString(S)}) and U(${setToString(complement)}) (contradiction)`);
    }
  }
  
  return {
    valid: violations.length === 0,
    violations
  };
}

/************ Utility Functions ************/

/**
 * Enumerate all subsets of a finite set
 */
export function allSubsets<A>(Aset: SetObj<A>): Set<A>[] {
  const elements = Aset.elems;
  const subsets: Set<A>[] = [];
  
  // Generate all 2^n subsets using bit manipulation
  for (let i = 0; i < Math.pow(2, elements.length); i++) {
    const subset = new Set<A>();
    for (let j = 0; j < elements.length; j++) {
      if ((i >> j) & 1) {
        subset.add(elements[j]!);
      }
    }
    subsets.push(subset);
  }
  
  return subsets;
}

/**
 * Convert set to string for debugging
 */
function setToString<A>(S: Set<A>): string {
  return `{${[...S].join(', ')}}`;
}


/**
 * Check if an ultrafilter is principal with given witness
 */
export function isPrincipalWith<A>(
  Aset: SetObj<A>,
  U: Ultrafilter<A>,
  a: A
): boolean {
  const singleton = new Set<A>([a]);
  return U.contains(singleton);
}

/************ Advanced Constructions ************/

/**
 * Create ultrafilter from codensity unit operation
 * This demonstrates Œ∑_A(a) ‚Ü¶ principal ultrafilter at a
 */
export function principalFromCodensity<A>(
  Aset: SetObj<A>,
  a: A
): Ultrafilter<A> {
  const { of } = mkCodensityMonad(MiniFinSet, G_inclusion);
  const t = of(Aset)(a);
  return ultrafilterFromCodensity(Aset, t);
}

/**
 * Verify that codensity unit gives principal ultrafilters
 */
export function verifyPrincipalProperty<A>(
  Aset: SetObj<A>
): { verified: boolean; details: any[] } {
  const details: any[] = [];
  let verified = true;
  
  for (const a of Aset.elems) {
    const U = principalFromCodensity(Aset, a);
    const P = principalUltrafilter(Aset, a);
    
    // Test on several subsets
    const testSubsets = allSubsets(Aset).slice(0, 8);
    let agreesOnAll = true;
    
    for (const S of testSubsets) {
      const UcontainsS = U.contains(S);
      const PcontainsS = P.contains(S);
      
      if (UcontainsS !== PcontainsS) {
        agreesOnAll = false;
        break;
      }
    }
    
    details.push({
      element: a,
      isPrincipal: U.isPrincipal,
      witness: U.principalWitness,
      agreesWithPrincipal: agreesOnAll
    });
    
    if (!agreesOnAll || !U.isPrincipal || U.principalWitness !== a) {
      verified = false;
    }
  }
  
  return { verified, details };
}

/************ Demonstration Function ************/

export function demonstrateUltrafilter(): void {
  console.log('='.repeat(70));
  console.log('üéØ ULTRAFILTER FROM CODENSITY DEMONSTRATION');
  console.log('='.repeat(70));

  console.log('\nüìê MATHEMATICAL CONNECTION:');
  console.log('   Codensity T^G(A) = ‚à´_b [[A, G b], G b]');
  console.log('   For G: FinSet ‚Üí Set inclusion, Bool component gives ultrafilters');
  console.log('   U(S) := (t)_2(œá_S) == true where œá_S: A ‚Üí Bool');

  console.log('\nüî¢ MINI FINSET CATEGORY:');
  console.log(`   Objects: 1 = {null}, 2 = {false, true}`);
  console.log(`   Morphisms: ${MiniFinSet.morphisms.length} total`);
  console.log('   Inclusion G: identity on carriers');

  // Test with small set A = {a, b, c}
  const A: SetObj<string> = {
    id: "A",
    elems: ["a", "b", "c"],
    eq: (x, y) => x === y
  };

  console.log(`\nüéÆ EXAMPLE: A = {${A.elems.join(', ')}} (|A| = ${A.elems.length})`);

  try {
    // Test principal ultrafilter construction
    const testElement = "b";
    const U = principalFromCodensity(A, testElement);
    const P = principalUltrafilter(A, testElement);
    
    console.log(`   Principal ultrafilter at "${testElement}":`);
    console.log(`   Is principal: ${U.isPrincipal ? '‚úÖ' : '‚ùå'}`);
    console.log(`   Witness: ${U.principalWitness}`);
    
    // Test on various subsets
    const testSubsets = [
      subset<string>([]),
      subset(["a"]),
      subset(["b"]), 
      subset(["c"]),
      subset(["a", "b"]),
      subset(["b", "c"]),
      subset(["a", "b", "c"])
    ];
    
    console.log('\n   Subset membership:');
    testSubsets.forEach(S => {
      const UcontainsS = U.contains(S);
      const PcontainsS = P.contains(S);
      const match = UcontainsS === PcontainsS ? '‚úÖ' : '‚ùå';
      console.log(`     U(${setToString(S)}) = ${UcontainsS}, P(${setToString(S)}) = ${PcontainsS} ${match}`);
    });
    
    // Verify ultrafilter laws
    const lawCheck = verifyUltrafilterLaws(A, U);
    console.log(`\n   Ultrafilter laws: ${lawCheck.valid ? '‚úÖ' : '‚ùå'}`);
    if (!lawCheck.valid) {
      lawCheck.violations.forEach(v => console.log(`     Violation: ${v}`));
    }
    
  } catch (error) {
    console.log('   Error:', (error as Error).message);
  }

  console.log('\n' + '='.repeat(70));
  console.log('‚úÖ ULTRAFILTER FEATURES:');
  console.log('   üîπ Construction from codensity monads');
  console.log('   üîπ Principal ultrafilters via Œ∑_A(a)');
  console.log('   üîπ Boolean component interpretation');
  console.log('   üîπ Characteristic function evaluation');
  console.log('   üîπ Ultrafilter law verification');
  console.log('   üîπ Integration with finite set theory');
  console.log('='.repeat(70));
}

