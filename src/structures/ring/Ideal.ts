import type { FiniteRing } from "./Ring";

/** Two-sided ideal in a (possibly noncommutative) finite ring. */
export type Ideal<A> = {
  ring: FiniteRing<A>;
  elems: A[]; // saturated, closed under +, neg, and r*s, s*r for r∈R
};

/** Saturate the two-sided ideal generated by a set of generators (finite closure). */
export function idealGeneratedBy<A>(R: FiniteRing<A>, gens: A[]): Ideal<A> {
  const S: A[] = [];
  const has = (x:A)=> S.some(y=>R.eq(x,y));
  const add = (x:A)=> { if (!has(x)) S.push(x); };
  add(R.zero);
  for (const g of gens) add(g);

  let changed = true;
  while (changed) {
    changed = false;
    // closure under additive inverses
    for (const x of S.slice()) { const nx = R.neg(x); if (!has(nx)) { add(nx); changed = true; } }
    // closure under addition
    for (const x of S.slice()) for (const y of S.slice()) {
      const s = R.add(x,y); if (!has(s)) { add(s); changed = true; }
    }
    // absorb multiplication by any ring element on both sides
    for (const r of R.elems) for (const s of S.slice()) {
      const rs = R.mul(r,s); if (!has(rs)) { add(rs); changed = true; }
      const sr = R.mul(s,r); if (!has(sr)) { add(sr); changed = true; }
    }
  }
  return { ring:R, elems:S };
}

/** Check ideal laws (debug). */
export function isIdeal<A>(I: Ideal<A>): boolean {
  const R = I.ring;
  const E = I.elems;
  const inI = (x:A)=> E.some(y=>R.eq(x,y));
  if (!inI(R.zero)) return false;
  for (const x of E) if (!inI(R.neg(x))) return false;
  for (const x of E) for (const y of E) if (!inI(R.add(x,y))) return false;
  for (const r of R.elems) for (const x of E) {
    if (!inI(R.mul(r,x))) return false;
    if (!inI(R.mul(x,r))) return false;
  }
  return true;
}

/** Quotient ring R/I (finite): classes by a~b iff a-b ∈ I. */
export function quotientRing<A>(R: FiniteRing<A>, I: Ideal<A>) {
  if (I.ring !== R) throw new Error("quotientRing: ideal from different ring");
  // Partition into equivalence classes using union-find over indices.
  const idx = new Map<number, number>(); // index -> class representative index
  const parent = Array(R.elems.length).fill(0).map((_,i)=>i);
  const find = (i:number): number => parent[i]===i ? i : (parent[i]=find(parent[i]));
  const uni = (i:number,j:number)=> { i=find(i); j=find(j); if (i!==j) parent[j]=i; };

  const inI = (x:A)=> I.elems.some(y=>R.eq(x,y));
  // union i ~ j if (ei - ej) ∈ I
  for (let i=0;i<R.elems.length;i++) for (let j=0;j<R.elems.length;j++) {
    const ei = R.elems[i]!;
    const ej = R.elems[j]!;
    const diff = R.add(ei, R.neg(ej));
    if (inI(diff)) uni(i,j);
  }

  // classes & representatives
  const clsId = (i:number)=> find(i);
  const repOfId = new Map<number, number>();
  for (let i=0;i<R.elems.length;i++) {
    const c = clsId(i);
    if (!repOfId.has(c)) repOfId.set(c, i);
  }

  type Cls = { repIndex: number };
  const classes: Cls[] = Array.from(repOfId.values()).map(repIndex => ({ repIndex }));
  const eq = (x:Cls,y:Cls)=> clsId(x.repIndex)===clsId(y.repIndex);

  const lift = (x:Cls): A => R.elems[x.repIndex]!;

  const add = (x:Cls,y:Cls): Cls => {
    const s = R.add(lift(x), lift(y));
    const k = R.elems.findIndex(e=> R.eq(e,s));
    if (k === -1) throw new Error("Element not found in ring");
    return { repIndex: clsId(k) };
  };
  const neg = (x:Cls): Cls => {
    const s = R.neg(lift(x));
    const k = R.elems.findIndex(e=> R.eq(e,s));
    if (k === -1) throw new Error("Element not found in ring");
    return { repIndex: clsId(k) };
  };
  const mul = (x:Cls,y:Cls): Cls => {
    const p = R.mul(lift(x), lift(y));
    const k = R.elems.findIndex(e=> R.eq(e,p));
    if (k === -1) throw new Error("Element not found in ring");
    return { repIndex: clsId(k) };
  };

  // zero/one
  const zIdx = R.elems.findIndex(e=> R.eq(e, R.zero));
  const oIdx = R.elems.findIndex(e=> R.eq(e, R.one));
  const zero = { repIndex: clsId(zIdx) };
  const one  = { repIndex: clsId(oIdx) };

  return {
    ring: <const>{ elems: classes, eq, add, zero, neg, mul, one, comm: R.comm },
    proj: (a:A): Cls => ({ repIndex: clsId(R.elems.findIndex(e=>R.eq(e,a))) })
  };
}

/** Is a finite commutative ring a field? (every nonzero is invertible) */
export function isFieldComm<A>(R: FiniteRing<A>): boolean {
  if (!R.comm) return false;
  const zero = R.zero;
  const nonzero = R.elems.filter(e=> !R.eq(e, zero));
  for (const a of nonzero) {
    let hasInv = false;
    for (const b of nonzero) if (R.eq(R.mul(a,b), R.one) && R.eq(R.mul(b,a), R.one)) { hasInv=true; break; }
    if (!hasInv) return false;
  }
  return true;
}

/** Is prime ideal (commutative): ab∈I ⇒ a∈I or b∈I. */
export function isPrimeIdealComm<A>(I: Ideal<A>): boolean {
  const R = I.ring;
  if (!R.comm) return false;
  const inI = (x:A)=> I.elems.some(y=>R.eq(x,y));
  for (const a of R.elems) for (const b of R.elems) {
    if (inI(R.mul(a,b)) && !inI(a) && !inI(b)) return false;
  }
  return true;
}

/** Is maximal ideal (commutative): iff R/I is a field (finite). */
export function isMaximalIdealComm<A>(I: Ideal<A>): boolean {
  const { ring:Q } = quotientRing(I.ring, I);
  return isFieldComm(Q);
}