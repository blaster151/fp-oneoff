import { describe, it, expect } from "vitest";
import { ZnRing, M2ZnRing, checkRingLaws } from "../Ring";
import { idealGeneratedBy, isIdeal, quotientRing, isPrimeIdealComm, isMaximalIdealComm, isFieldComm } from "../Ideal";

describe("Ideals in finite rings", () => {
  it("ideal generated by single element in ℤ/6", () => {
    const Z6 = ZnRing(6);
    const I = idealGeneratedBy(Z6, [2]);
    
    expect(isIdeal(I)).toBe(true);
    expect(I.elems).toEqual([0, 2, 4]); // multiples of 2 in ℤ/6
  });

  it("ideal generated by {2,3} in ℤ/6", () => {
    const Z6 = ZnRing(6);
    const I = idealGeneratedBy(Z6, [2, 3]);
    
    expect(isIdeal(I)).toBe(true);
    expect(I.elems.length).toBe(6); // gcd(2,3) = 1, so ideal is whole ring
    expect(I.elems.sort()).toEqual([0, 1, 2, 3, 4, 5]); // all elements of ℤ/6
  });

  it("quotient ring ℤ/6 / ⟨2⟩ ≅ ℤ/3", () => {
    const Z6 = ZnRing(6);
    const I = idealGeneratedBy(Z6, [2]);
    const { ring: Q, proj } = quotientRing(Z6, I);
    
    expect(Q.elems.length).toBe(2); // should have 2 elements: [0], [1] (since ⟨2⟩ = {0,2,4})
    
    // Check that projection works
    expect(Q.eq(proj(0), proj(2))).toBe(true); // 0 ≡ 2 (mod ⟨2⟩)
    expect(Q.eq(proj(0), proj(4))).toBe(true); // 0 ≡ 4 (mod ⟨2⟩)
    expect(Q.eq(proj(1), proj(3))).toBe(true); // 1 ≡ 3 (mod ⟨2⟩)
    expect(Q.eq(proj(1), proj(5))).toBe(true); // 1 ≡ 5 (mod ⟨2⟩)
  });

  it("prime ideals in ℤ/6", () => {
    const Z6 = ZnRing(6);
    
    // ⟨2⟩ is prime: if ab ∈ ⟨2⟩ then a ∈ ⟨2⟩ or b ∈ ⟨2⟩
    const I2 = idealGeneratedBy(Z6, [2]);
    expect(isPrimeIdealComm(I2)).toBe(true);
    
    // ⟨3⟩ is prime
    const I3 = idealGeneratedBy(Z6, [3]);
    expect(isPrimeIdealComm(I3)).toBe(true);
    
    // ⟨0⟩ is not prime (6 = 2*3 ∈ ⟨0⟩ but 2,3 ∉ ⟨0⟩)
    const I0 = idealGeneratedBy(Z6, [0]);
    expect(isPrimeIdealComm(I0)).toBe(false);
  });

  it("maximal ideals in ℤ/6", () => {
    const Z6 = ZnRing(6);
    
    // ⟨2⟩ is maximal: ℤ/6 / ⟨2⟩ ≅ ℤ/3 is a field
    const I2 = idealGeneratedBy(Z6, [2]);
    expect(isMaximalIdealComm(I2)).toBe(true);
    
    // ⟨3⟩ is maximal: ℤ/6 / ⟨3⟩ ≅ ℤ/2 is a field
    const I3 = idealGeneratedBy(Z6, [3]);
    expect(isMaximalIdealComm(I3)).toBe(true);
  });

  it("ℤ/5 is a field", () => {
    const Z5 = ZnRing(5);
    expect(isFieldComm(Z5)).toBe(true);
  });

  it("ℤ/6 is not a field", () => {
    const Z6 = ZnRing(6);
    expect(isFieldComm(Z6)).toBe(false); // 2 has no multiplicative inverse
  });

  it("ideals in M₂(ℤ/2)", () => {
    const M2Z2 = M2ZnRing(2);
    
    // Ideal generated by matrix with 1 in top-left
    const A = {a:1,b:0,c:0,d:0};
    const I = idealGeneratedBy(M2Z2, [A]);
    
    expect(isIdeal(I)).toBe(true);
    expect(I.elems.length).toBeGreaterThan(1); // should contain more than just A
  });

  it("quotient ring preserves ring structure", () => {
    const Z8 = ZnRing(8);
    const I = idealGeneratedBy(Z8, [4]); // ⟨4⟩ = {0,4}
    const { ring: Q } = quotientRing(Z8, I);
    
    // Check ring laws in quotient
    const check = checkRingLaws(Q);
    expect(check.ok).toBe(true);
    
    // Q should have 4 elements: [0], [1], [2], [3]
    expect(Q.elems.length).toBe(4);
  });
});